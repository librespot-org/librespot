// This file is generated by rust-protobuf 2.8.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `playlist4changes.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_2;

#[derive(PartialEq,Clone,Default)]
pub struct ChangeInfo {
    // message fields
    user: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<i32>,
    admin: ::std::option::Option<bool>,
    undo: ::std::option::Option<bool>,
    redo: ::std::option::Option<bool>,
    merge: ::std::option::Option<bool>,
    compressed: ::std::option::Option<bool>,
    migration: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeInfo {
    fn default() -> &'a ChangeInfo {
        <ChangeInfo as ::protobuf::Message>::default_instance()
    }
}

impl ChangeInfo {
    pub fn new() -> ChangeInfo {
        ::std::default::Default::default()
    }

    // optional string user = 1;


    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 timestamp = 2;


    pub fn get_timestamp(&self) -> i32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional bool admin = 3;


    pub fn get_admin(&self) -> bool {
        self.admin.unwrap_or(false)
    }
    pub fn clear_admin(&mut self) {
        self.admin = ::std::option::Option::None;
    }

    pub fn has_admin(&self) -> bool {
        self.admin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: bool) {
        self.admin = ::std::option::Option::Some(v);
    }

    // optional bool undo = 4;


    pub fn get_undo(&self) -> bool {
        self.undo.unwrap_or(false)
    }
    pub fn clear_undo(&mut self) {
        self.undo = ::std::option::Option::None;
    }

    pub fn has_undo(&self) -> bool {
        self.undo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undo(&mut self, v: bool) {
        self.undo = ::std::option::Option::Some(v);
    }

    // optional bool redo = 5;


    pub fn get_redo(&self) -> bool {
        self.redo.unwrap_or(false)
    }
    pub fn clear_redo(&mut self) {
        self.redo = ::std::option::Option::None;
    }

    pub fn has_redo(&self) -> bool {
        self.redo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redo(&mut self, v: bool) {
        self.redo = ::std::option::Option::Some(v);
    }

    // optional bool merge = 6;


    pub fn get_merge(&self) -> bool {
        self.merge.unwrap_or(false)
    }
    pub fn clear_merge(&mut self) {
        self.merge = ::std::option::Option::None;
    }

    pub fn has_merge(&self) -> bool {
        self.merge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge(&mut self, v: bool) {
        self.merge = ::std::option::Option::Some(v);
    }

    // optional bool compressed = 7;


    pub fn get_compressed(&self) -> bool {
        self.compressed.unwrap_or(false)
    }
    pub fn clear_compressed(&mut self) {
        self.compressed = ::std::option::Option::None;
    }

    pub fn has_compressed(&self) -> bool {
        self.compressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compressed(&mut self, v: bool) {
        self.compressed = ::std::option::Option::Some(v);
    }

    // optional bool migration = 8;


    pub fn get_migration(&self) -> bool {
        self.migration.unwrap_or(false)
    }
    pub fn clear_migration(&mut self) {
        self.migration = ::std::option::Option::None;
    }

    pub fn has_migration(&self) -> bool {
        self.migration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migration(&mut self, v: bool) {
        self.migration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ChangeInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.admin = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.undo = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.redo = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.merge = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.compressed = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.migration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.admin {
            my_size += 2;
        }
        if let Some(v) = self.undo {
            my_size += 2;
        }
        if let Some(v) = self.redo {
            my_size += 2;
        }
        if let Some(v) = self.merge {
            my_size += 2;
        }
        if let Some(v) = self.compressed {
            my_size += 2;
        }
        if let Some(v) = self.migration {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.admin {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.undo {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.redo {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.merge {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.compressed {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.migration {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeInfo {
        ChangeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user",
                    |m: &ChangeInfo| { &m.user },
                    |m: &mut ChangeInfo| { &mut m.user },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "timestamp",
                    |m: &ChangeInfo| { &m.timestamp },
                    |m: &mut ChangeInfo| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "admin",
                    |m: &ChangeInfo| { &m.admin },
                    |m: &mut ChangeInfo| { &mut m.admin },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "undo",
                    |m: &ChangeInfo| { &m.undo },
                    |m: &mut ChangeInfo| { &mut m.undo },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "redo",
                    |m: &ChangeInfo| { &m.redo },
                    |m: &mut ChangeInfo| { &mut m.redo },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "merge",
                    |m: &ChangeInfo| { &m.merge },
                    |m: &mut ChangeInfo| { &mut m.merge },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "compressed",
                    |m: &ChangeInfo| { &m.compressed },
                    |m: &mut ChangeInfo| { &mut m.compressed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "migration",
                    |m: &ChangeInfo| { &m.migration },
                    |m: &mut ChangeInfo| { &mut m.migration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChangeInfo>(
                    "ChangeInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangeInfo {
        static mut instance: ::protobuf::lazy::Lazy<ChangeInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangeInfo,
        };
        unsafe {
            instance.get(ChangeInfo::new)
        }
    }
}

impl ::protobuf::Clear for ChangeInfo {
    fn clear(&mut self) {
        self.user.clear();
        self.timestamp = ::std::option::Option::None;
        self.admin = ::std::option::Option::None;
        self.undo = ::std::option::Option::None;
        self.redo = ::std::option::Option::None;
        self.merge = ::std::option::Option::None;
        self.compressed = ::std::option::Option::None;
        self.migration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Delta {
    // message fields
    base_version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ops: ::protobuf::RepeatedField<super::playlist4ops::Op>,
    info: ::protobuf::SingularPtrField<ChangeInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Delta {
    fn default() -> &'a Delta {
        <Delta as ::protobuf::Message>::default_instance()
    }
}

impl Delta {
    pub fn new() -> Delta {
        ::std::default::Default::default()
    }

    // optional bytes base_version = 1;


    pub fn get_base_version(&self) -> &[u8] {
        match self.base_version.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_base_version(&mut self) {
        self.base_version.clear();
    }

    pub fn has_base_version(&self) -> bool {
        self.base_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.base_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.base_version.is_none() {
            self.base_version.set_default();
        }
        self.base_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_base_version(&mut self) -> ::std::vec::Vec<u8> {
        self.base_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated .Op ops = 2;


    pub fn get_ops(&self) -> &[super::playlist4ops::Op] {
        &self.ops
    }
    pub fn clear_ops(&mut self) {
        self.ops.clear();
    }

    // Param is passed by value, moved
    pub fn set_ops(&mut self, v: ::protobuf::RepeatedField<super::playlist4ops::Op>) {
        self.ops = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ops(&mut self) -> &mut ::protobuf::RepeatedField<super::playlist4ops::Op> {
        &mut self.ops
    }

    // Take field
    pub fn take_ops(&mut self) -> ::protobuf::RepeatedField<super::playlist4ops::Op> {
        ::std::mem::replace(&mut self.ops, ::protobuf::RepeatedField::new())
    }

    // optional .ChangeInfo info = 4;


    pub fn get_info(&self) -> &ChangeInfo {
        self.info.as_ref().unwrap_or_else(|| ChangeInfo::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ChangeInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ChangeInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ChangeInfo {
        self.info.take().unwrap_or_else(|| ChangeInfo::new())
    }
}

impl ::protobuf::Message for Delta {
    fn is_initialized(&self) -> bool {
        for v in &self.ops {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.base_version)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ops)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        for value in &self.ops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base_version.as_ref() {
            os.write_bytes(1, &v)?;
        }
        for v in &self.ops {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Delta {
        Delta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "base_version",
                    |m: &Delta| { &m.base_version },
                    |m: &mut Delta| { &mut m.base_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::playlist4ops::Op>>(
                    "ops",
                    |m: &Delta| { &m.ops },
                    |m: &mut Delta| { &mut m.ops },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChangeInfo>>(
                    "info",
                    |m: &Delta| { &m.info },
                    |m: &mut Delta| { &mut m.info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Delta>(
                    "Delta",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Delta {
        static mut instance: ::protobuf::lazy::Lazy<Delta> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Delta,
        };
        unsafe {
            instance.get(Delta::new)
        }
    }
}

impl ::protobuf::Clear for Delta {
    fn clear(&mut self) {
        self.base_version.clear();
        self.ops.clear();
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Delta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Delta {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Merge {
    // message fields
    base_version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    merge_version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    info: ::protobuf::SingularPtrField<ChangeInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Merge {
    fn default() -> &'a Merge {
        <Merge as ::protobuf::Message>::default_instance()
    }
}

impl Merge {
    pub fn new() -> Merge {
        ::std::default::Default::default()
    }

    // optional bytes base_version = 1;


    pub fn get_base_version(&self) -> &[u8] {
        match self.base_version.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_base_version(&mut self) {
        self.base_version.clear();
    }

    pub fn has_base_version(&self) -> bool {
        self.base_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.base_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.base_version.is_none() {
            self.base_version.set_default();
        }
        self.base_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_base_version(&mut self) -> ::std::vec::Vec<u8> {
        self.base_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes merge_version = 2;


    pub fn get_merge_version(&self) -> &[u8] {
        match self.merge_version.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_merge_version(&mut self) {
        self.merge_version.clear();
    }

    pub fn has_merge_version(&self) -> bool {
        self.merge_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.merge_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merge_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.merge_version.is_none() {
            self.merge_version.set_default();
        }
        self.merge_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_merge_version(&mut self) -> ::std::vec::Vec<u8> {
        self.merge_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .ChangeInfo info = 4;


    pub fn get_info(&self) -> &ChangeInfo {
        self.info.as_ref().unwrap_or_else(|| ChangeInfo::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ChangeInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ChangeInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ChangeInfo {
        self.info.take().unwrap_or_else(|| ChangeInfo::new())
    }
}

impl ::protobuf::Message for Merge {
    fn is_initialized(&self) -> bool {
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.base_version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.merge_version)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.merge_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base_version.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.merge_version.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Merge {
        Merge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "base_version",
                    |m: &Merge| { &m.base_version },
                    |m: &mut Merge| { &mut m.base_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "merge_version",
                    |m: &Merge| { &m.merge_version },
                    |m: &mut Merge| { &mut m.merge_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChangeInfo>>(
                    "info",
                    |m: &Merge| { &m.info },
                    |m: &mut Merge| { &mut m.info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Merge>(
                    "Merge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Merge {
        static mut instance: ::protobuf::lazy::Lazy<Merge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Merge,
        };
        unsafe {
            instance.get(Merge::new)
        }
    }
}

impl ::protobuf::Clear for Merge {
    fn clear(&mut self) {
        self.base_version.clear();
        self.merge_version.clear();
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Merge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Merge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeSet {
    // message fields
    kind: ::std::option::Option<ChangeSet_Kind>,
    delta: ::protobuf::SingularPtrField<Delta>,
    merge: ::protobuf::SingularPtrField<Merge>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeSet {
    fn default() -> &'a ChangeSet {
        <ChangeSet as ::protobuf::Message>::default_instance()
    }
}

impl ChangeSet {
    pub fn new() -> ChangeSet {
        ::std::default::Default::default()
    }

    // optional .ChangeSet.Kind kind = 1;


    pub fn get_kind(&self) -> ChangeSet_Kind {
        self.kind.unwrap_or(ChangeSet_Kind::KIND_UNKNOWN)
    }
    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ChangeSet_Kind) {
        self.kind = ::std::option::Option::Some(v);
    }

    // optional .Delta delta = 2;


    pub fn get_delta(&self) -> &Delta {
        self.delta.as_ref().unwrap_or_else(|| Delta::default_instance())
    }
    pub fn clear_delta(&mut self) {
        self.delta.clear();
    }

    pub fn has_delta(&self) -> bool {
        self.delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta(&mut self, v: Delta) {
        self.delta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delta(&mut self) -> &mut Delta {
        if self.delta.is_none() {
            self.delta.set_default();
        }
        self.delta.as_mut().unwrap()
    }

    // Take field
    pub fn take_delta(&mut self) -> Delta {
        self.delta.take().unwrap_or_else(|| Delta::new())
    }

    // optional .Merge merge = 3;


    pub fn get_merge(&self) -> &Merge {
        self.merge.as_ref().unwrap_or_else(|| Merge::default_instance())
    }
    pub fn clear_merge(&mut self) {
        self.merge.clear();
    }

    pub fn has_merge(&self) -> bool {
        self.merge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge(&mut self, v: Merge) {
        self.merge = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merge(&mut self) -> &mut Merge {
        if self.merge.is_none() {
            self.merge.set_default();
        }
        self.merge.as_mut().unwrap()
    }

    // Take field
    pub fn take_merge(&mut self) -> Merge {
        self.merge.take().unwrap_or_else(|| Merge::new())
    }
}

impl ::protobuf::Message for ChangeSet {
    fn is_initialized(&self) -> bool {
        for v in &self.delta {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.merge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delta)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.merge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.kind {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.delta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.merge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.kind {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.delta.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.merge.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeSet {
        ChangeSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChangeSet_Kind>>(
                    "kind",
                    |m: &ChangeSet| { &m.kind },
                    |m: &mut ChangeSet| { &mut m.kind },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Delta>>(
                    "delta",
                    |m: &ChangeSet| { &m.delta },
                    |m: &mut ChangeSet| { &mut m.delta },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Merge>>(
                    "merge",
                    |m: &ChangeSet| { &m.merge },
                    |m: &mut ChangeSet| { &mut m.merge },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChangeSet>(
                    "ChangeSet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangeSet {
        static mut instance: ::protobuf::lazy::Lazy<ChangeSet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangeSet,
        };
        unsafe {
            instance.get(ChangeSet::new)
        }
    }
}

impl ::protobuf::Clear for ChangeSet {
    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.delta.clear();
        self.merge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangeSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeSet {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ChangeSet_Kind {
    KIND_UNKNOWN = 0,
    DELTA = 2,
    MERGE = 3,
}

impl ::protobuf::ProtobufEnum for ChangeSet_Kind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChangeSet_Kind> {
        match value {
            0 => ::std::option::Option::Some(ChangeSet_Kind::KIND_UNKNOWN),
            2 => ::std::option::Option::Some(ChangeSet_Kind::DELTA),
            3 => ::std::option::Option::Some(ChangeSet_Kind::MERGE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChangeSet_Kind] = &[
            ChangeSet_Kind::KIND_UNKNOWN,
            ChangeSet_Kind::DELTA,
            ChangeSet_Kind::MERGE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ChangeSet_Kind", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ChangeSet_Kind {
}

impl ::std::default::Default for ChangeSet_Kind {
    fn default() -> Self {
        ChangeSet_Kind::KIND_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeSet_Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RevisionTaggedChangeSet {
    // message fields
    revision: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    change_set: ::protobuf::SingularPtrField<ChangeSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RevisionTaggedChangeSet {
    fn default() -> &'a RevisionTaggedChangeSet {
        <RevisionTaggedChangeSet as ::protobuf::Message>::default_instance()
    }
}

impl RevisionTaggedChangeSet {
    pub fn new() -> RevisionTaggedChangeSet {
        ::std::default::Default::default()
    }

    // optional bytes revision = 1;


    pub fn get_revision(&self) -> &[u8] {
        match self.revision.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_revision(&mut self) {
        self.revision.clear();
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.revision = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.revision.is_none() {
            self.revision.set_default();
        }
        self.revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .ChangeSet change_set = 2;


    pub fn get_change_set(&self) -> &ChangeSet {
        self.change_set.as_ref().unwrap_or_else(|| ChangeSet::default_instance())
    }
    pub fn clear_change_set(&mut self) {
        self.change_set.clear();
    }

    pub fn has_change_set(&self) -> bool {
        self.change_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_set(&mut self, v: ChangeSet) {
        self.change_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_set(&mut self) -> &mut ChangeSet {
        if self.change_set.is_none() {
            self.change_set.set_default();
        }
        self.change_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_change_set(&mut self) -> ChangeSet {
        self.change_set.take().unwrap_or_else(|| ChangeSet::new())
    }
}

impl ::protobuf::Message for RevisionTaggedChangeSet {
    fn is_initialized(&self) -> bool {
        for v in &self.change_set {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.revision)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.change_set)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.change_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.revision.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.change_set.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RevisionTaggedChangeSet {
        RevisionTaggedChangeSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "revision",
                    |m: &RevisionTaggedChangeSet| { &m.revision },
                    |m: &mut RevisionTaggedChangeSet| { &mut m.revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChangeSet>>(
                    "change_set",
                    |m: &RevisionTaggedChangeSet| { &m.change_set },
                    |m: &mut RevisionTaggedChangeSet| { &mut m.change_set },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RevisionTaggedChangeSet>(
                    "RevisionTaggedChangeSet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RevisionTaggedChangeSet {
        static mut instance: ::protobuf::lazy::Lazy<RevisionTaggedChangeSet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RevisionTaggedChangeSet,
        };
        unsafe {
            instance.get(RevisionTaggedChangeSet::new)
        }
    }
}

impl ::protobuf::Clear for RevisionTaggedChangeSet {
    fn clear(&mut self) {
        self.revision.clear();
        self.change_set.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RevisionTaggedChangeSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RevisionTaggedChangeSet {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Diff {
    // message fields
    from_revision: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ops: ::protobuf::RepeatedField<super::playlist4ops::Op>,
    to_revision: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Diff {
    fn default() -> &'a Diff {
        <Diff as ::protobuf::Message>::default_instance()
    }
}

impl Diff {
    pub fn new() -> Diff {
        ::std::default::Default::default()
    }

    // optional bytes from_revision = 1;


    pub fn get_from_revision(&self) -> &[u8] {
        match self.from_revision.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_from_revision(&mut self) {
        self.from_revision.clear();
    }

    pub fn has_from_revision(&self) -> bool {
        self.from_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.from_revision = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.from_revision.is_none() {
            self.from_revision.set_default();
        }
        self.from_revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.from_revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated .Op ops = 2;


    pub fn get_ops(&self) -> &[super::playlist4ops::Op] {
        &self.ops
    }
    pub fn clear_ops(&mut self) {
        self.ops.clear();
    }

    // Param is passed by value, moved
    pub fn set_ops(&mut self, v: ::protobuf::RepeatedField<super::playlist4ops::Op>) {
        self.ops = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ops(&mut self) -> &mut ::protobuf::RepeatedField<super::playlist4ops::Op> {
        &mut self.ops
    }

    // Take field
    pub fn take_ops(&mut self) -> ::protobuf::RepeatedField<super::playlist4ops::Op> {
        ::std::mem::replace(&mut self.ops, ::protobuf::RepeatedField::new())
    }

    // optional bytes to_revision = 3;


    pub fn get_to_revision(&self) -> &[u8] {
        match self.to_revision.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_to_revision(&mut self) {
        self.to_revision.clear();
    }

    pub fn has_to_revision(&self) -> bool {
        self.to_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.to_revision = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.to_revision.is_none() {
            self.to_revision.set_default();
        }
        self.to_revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_to_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.to_revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Diff {
    fn is_initialized(&self) -> bool {
        for v in &self.ops {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.from_revision)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ops)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.to_revision)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.from_revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        for value in &self.ops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.to_revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.from_revision.as_ref() {
            os.write_bytes(1, &v)?;
        }
        for v in &self.ops {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.to_revision.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Diff {
        Diff::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from_revision",
                    |m: &Diff| { &m.from_revision },
                    |m: &mut Diff| { &mut m.from_revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::playlist4ops::Op>>(
                    "ops",
                    |m: &Diff| { &m.ops },
                    |m: &mut Diff| { &mut m.ops },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to_revision",
                    |m: &Diff| { &m.to_revision },
                    |m: &mut Diff| { &mut m.to_revision },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Diff>(
                    "Diff",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Diff {
        static mut instance: ::protobuf::lazy::Lazy<Diff> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Diff,
        };
        unsafe {
            instance.get(Diff::new)
        }
    }
}

impl ::protobuf::Clear for Diff {
    fn clear(&mut self) {
        self.from_revision.clear();
        self.ops.clear();
        self.to_revision.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Diff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Diff {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDump {
    // message fields
    latestRevision: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    length: ::std::option::Option<i32>,
    attributes: ::protobuf::SingularPtrField<super::playlist4meta::ListAttributes>,
    checksum: ::protobuf::SingularPtrField<super::playlist4meta::ListChecksum>,
    contents: ::protobuf::SingularPtrField<super::playlist4content::ListItems>,
    pendingDeltas: ::protobuf::RepeatedField<Delta>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDump {
    fn default() -> &'a ListDump {
        <ListDump as ::protobuf::Message>::default_instance()
    }
}

impl ListDump {
    pub fn new() -> ListDump {
        ::std::default::Default::default()
    }

    // optional bytes latestRevision = 1;


    pub fn get_latestRevision(&self) -> &[u8] {
        match self.latestRevision.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_latestRevision(&mut self) {
        self.latestRevision.clear();
    }

    pub fn has_latestRevision(&self) -> bool {
        self.latestRevision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latestRevision(&mut self, v: ::std::vec::Vec<u8>) {
        self.latestRevision = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_latestRevision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.latestRevision.is_none() {
            self.latestRevision.set_default();
        }
        self.latestRevision.as_mut().unwrap()
    }

    // Take field
    pub fn take_latestRevision(&mut self) -> ::std::vec::Vec<u8> {
        self.latestRevision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 length = 2;


    pub fn get_length(&self) -> i32 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional .ListAttributes attributes = 3;


    pub fn get_attributes(&self) -> &super::playlist4meta::ListAttributes {
        self.attributes.as_ref().unwrap_or_else(|| super::playlist4meta::ListAttributes::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: super::playlist4meta::ListAttributes) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut super::playlist4meta::ListAttributes {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> super::playlist4meta::ListAttributes {
        self.attributes.take().unwrap_or_else(|| super::playlist4meta::ListAttributes::new())
    }

    // optional .ListChecksum checksum = 4;


    pub fn get_checksum(&self) -> &super::playlist4meta::ListChecksum {
        self.checksum.as_ref().unwrap_or_else(|| super::playlist4meta::ListChecksum::default_instance())
    }
    pub fn clear_checksum(&mut self) {
        self.checksum.clear();
    }

    pub fn has_checksum(&self) -> bool {
        self.checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: super::playlist4meta::ListChecksum) {
        self.checksum = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checksum(&mut self) -> &mut super::playlist4meta::ListChecksum {
        if self.checksum.is_none() {
            self.checksum.set_default();
        }
        self.checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_checksum(&mut self) -> super::playlist4meta::ListChecksum {
        self.checksum.take().unwrap_or_else(|| super::playlist4meta::ListChecksum::new())
    }

    // optional .ListItems contents = 5;


    pub fn get_contents(&self) -> &super::playlist4content::ListItems {
        self.contents.as_ref().unwrap_or_else(|| super::playlist4content::ListItems::default_instance())
    }
    pub fn clear_contents(&mut self) {
        self.contents.clear();
    }

    pub fn has_contents(&self) -> bool {
        self.contents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contents(&mut self, v: super::playlist4content::ListItems) {
        self.contents = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contents(&mut self) -> &mut super::playlist4content::ListItems {
        if self.contents.is_none() {
            self.contents.set_default();
        }
        self.contents.as_mut().unwrap()
    }

    // Take field
    pub fn take_contents(&mut self) -> super::playlist4content::ListItems {
        self.contents.take().unwrap_or_else(|| super::playlist4content::ListItems::new())
    }

    // repeated .Delta pendingDeltas = 7;


    pub fn get_pendingDeltas(&self) -> &[Delta] {
        &self.pendingDeltas
    }
    pub fn clear_pendingDeltas(&mut self) {
        self.pendingDeltas.clear();
    }

    // Param is passed by value, moved
    pub fn set_pendingDeltas(&mut self, v: ::protobuf::RepeatedField<Delta>) {
        self.pendingDeltas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pendingDeltas(&mut self) -> &mut ::protobuf::RepeatedField<Delta> {
        &mut self.pendingDeltas
    }

    // Take field
    pub fn take_pendingDeltas(&mut self) -> ::protobuf::RepeatedField<Delta> {
        ::std::mem::replace(&mut self.pendingDeltas, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListDump {
    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checksum {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contents {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pendingDeltas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.latestRevision)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checksum)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contents)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pendingDeltas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.latestRevision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checksum.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.contents.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.pendingDeltas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.latestRevision.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.length {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checksum.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.contents.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.pendingDeltas {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDump {
        ListDump::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "latestRevision",
                    |m: &ListDump| { &m.latestRevision },
                    |m: &mut ListDump| { &mut m.latestRevision },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "length",
                    |m: &ListDump| { &m.length },
                    |m: &mut ListDump| { &mut m.length },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::playlist4meta::ListAttributes>>(
                    "attributes",
                    |m: &ListDump| { &m.attributes },
                    |m: &mut ListDump| { &mut m.attributes },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::playlist4meta::ListChecksum>>(
                    "checksum",
                    |m: &ListDump| { &m.checksum },
                    |m: &mut ListDump| { &mut m.checksum },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::playlist4content::ListItems>>(
                    "contents",
                    |m: &ListDump| { &m.contents },
                    |m: &mut ListDump| { &mut m.contents },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Delta>>(
                    "pendingDeltas",
                    |m: &ListDump| { &m.pendingDeltas },
                    |m: &mut ListDump| { &mut m.pendingDeltas },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListDump>(
                    "ListDump",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListDump {
        static mut instance: ::protobuf::lazy::Lazy<ListDump> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListDump,
        };
        unsafe {
            instance.get(ListDump::new)
        }
    }
}

impl ::protobuf::Clear for ListDump {
    fn clear(&mut self) {
        self.latestRevision.clear();
        self.length = ::std::option::Option::None;
        self.attributes.clear();
        self.checksum.clear();
        self.contents.clear();
        self.pendingDeltas.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDump {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDump {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListChanges {
    // message fields
    baseRevision: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    deltas: ::protobuf::RepeatedField<Delta>,
    wantResultingRevisions: ::std::option::Option<bool>,
    wantSyncResult: ::std::option::Option<bool>,
    dump: ::protobuf::SingularPtrField<ListDump>,
    nonces: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListChanges {
    fn default() -> &'a ListChanges {
        <ListChanges as ::protobuf::Message>::default_instance()
    }
}

impl ListChanges {
    pub fn new() -> ListChanges {
        ::std::default::Default::default()
    }

    // optional bytes baseRevision = 1;


    pub fn get_baseRevision(&self) -> &[u8] {
        match self.baseRevision.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_baseRevision(&mut self) {
        self.baseRevision.clear();
    }

    pub fn has_baseRevision(&self) -> bool {
        self.baseRevision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseRevision(&mut self, v: ::std::vec::Vec<u8>) {
        self.baseRevision = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_baseRevision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.baseRevision.is_none() {
            self.baseRevision.set_default();
        }
        self.baseRevision.as_mut().unwrap()
    }

    // Take field
    pub fn take_baseRevision(&mut self) -> ::std::vec::Vec<u8> {
        self.baseRevision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated .Delta deltas = 2;


    pub fn get_deltas(&self) -> &[Delta] {
        &self.deltas
    }
    pub fn clear_deltas(&mut self) {
        self.deltas.clear();
    }

    // Param is passed by value, moved
    pub fn set_deltas(&mut self, v: ::protobuf::RepeatedField<Delta>) {
        self.deltas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deltas(&mut self) -> &mut ::protobuf::RepeatedField<Delta> {
        &mut self.deltas
    }

    // Take field
    pub fn take_deltas(&mut self) -> ::protobuf::RepeatedField<Delta> {
        ::std::mem::replace(&mut self.deltas, ::protobuf::RepeatedField::new())
    }

    // optional bool wantResultingRevisions = 3;


    pub fn get_wantResultingRevisions(&self) -> bool {
        self.wantResultingRevisions.unwrap_or(false)
    }
    pub fn clear_wantResultingRevisions(&mut self) {
        self.wantResultingRevisions = ::std::option::Option::None;
    }

    pub fn has_wantResultingRevisions(&self) -> bool {
        self.wantResultingRevisions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wantResultingRevisions(&mut self, v: bool) {
        self.wantResultingRevisions = ::std::option::Option::Some(v);
    }

    // optional bool wantSyncResult = 4;


    pub fn get_wantSyncResult(&self) -> bool {
        self.wantSyncResult.unwrap_or(false)
    }
    pub fn clear_wantSyncResult(&mut self) {
        self.wantSyncResult = ::std::option::Option::None;
    }

    pub fn has_wantSyncResult(&self) -> bool {
        self.wantSyncResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wantSyncResult(&mut self, v: bool) {
        self.wantSyncResult = ::std::option::Option::Some(v);
    }

    // optional .ListDump dump = 5;


    pub fn get_dump(&self) -> &ListDump {
        self.dump.as_ref().unwrap_or_else(|| ListDump::default_instance())
    }
    pub fn clear_dump(&mut self) {
        self.dump.clear();
    }

    pub fn has_dump(&self) -> bool {
        self.dump.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dump(&mut self, v: ListDump) {
        self.dump = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dump(&mut self) -> &mut ListDump {
        if self.dump.is_none() {
            self.dump.set_default();
        }
        self.dump.as_mut().unwrap()
    }

    // Take field
    pub fn take_dump(&mut self) -> ListDump {
        self.dump.take().unwrap_or_else(|| ListDump::new())
    }

    // repeated int32 nonces = 6;


    pub fn get_nonces(&self) -> &[i32] {
        &self.nonces
    }
    pub fn clear_nonces(&mut self) {
        self.nonces.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonces(&mut self, v: ::std::vec::Vec<i32>) {
        self.nonces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nonces(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.nonces
    }

    // Take field
    pub fn take_nonces(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.nonces, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ListChanges {
    fn is_initialized(&self) -> bool {
        for v in &self.deltas {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dump {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.baseRevision)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deltas)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.wantResultingRevisions = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.wantSyncResult = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dump)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.nonces)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.baseRevision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        for value in &self.deltas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.wantResultingRevisions {
            my_size += 2;
        }
        if let Some(v) = self.wantSyncResult {
            my_size += 2;
        }
        if let Some(ref v) = self.dump.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.nonces {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.baseRevision.as_ref() {
            os.write_bytes(1, &v)?;
        }
        for v in &self.deltas {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.wantResultingRevisions {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.wantSyncResult {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.dump.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.nonces {
            os.write_int32(6, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListChanges {
        ListChanges::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "baseRevision",
                    |m: &ListChanges| { &m.baseRevision },
                    |m: &mut ListChanges| { &mut m.baseRevision },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Delta>>(
                    "deltas",
                    |m: &ListChanges| { &m.deltas },
                    |m: &mut ListChanges| { &mut m.deltas },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "wantResultingRevisions",
                    |m: &ListChanges| { &m.wantResultingRevisions },
                    |m: &mut ListChanges| { &mut m.wantResultingRevisions },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "wantSyncResult",
                    |m: &ListChanges| { &m.wantSyncResult },
                    |m: &mut ListChanges| { &mut m.wantSyncResult },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListDump>>(
                    "dump",
                    |m: &ListChanges| { &m.dump },
                    |m: &mut ListChanges| { &mut m.dump },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "nonces",
                    |m: &ListChanges| { &m.nonces },
                    |m: &mut ListChanges| { &mut m.nonces },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListChanges>(
                    "ListChanges",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListChanges {
        static mut instance: ::protobuf::lazy::Lazy<ListChanges> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListChanges,
        };
        unsafe {
            instance.get(ListChanges::new)
        }
    }
}

impl ::protobuf::Clear for ListChanges {
    fn clear(&mut self) {
        self.baseRevision.clear();
        self.deltas.clear();
        self.wantResultingRevisions = ::std::option::Option::None;
        self.wantSyncResult = ::std::option::Option::None;
        self.dump.clear();
        self.nonces.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListChanges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListChanges {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SelectedListContent {
    // message fields
    revision: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    length: ::std::option::Option<i32>,
    attributes: ::protobuf::SingularPtrField<super::playlist4meta::ListAttributes>,
    checksum: ::protobuf::SingularPtrField<super::playlist4meta::ListChecksum>,
    contents: ::protobuf::SingularPtrField<super::playlist4content::ListItems>,
    diff: ::protobuf::SingularPtrField<Diff>,
    syncResult: ::protobuf::SingularPtrField<Diff>,
    resultingRevisions: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    multipleHeads: ::std::option::Option<bool>,
    upToDate: ::std::option::Option<bool>,
    resolveAction: ::protobuf::RepeatedField<super::playlist4issues::ClientResolveAction>,
    issues: ::protobuf::RepeatedField<super::playlist4issues::ClientIssue>,
    nonces: ::std::vec::Vec<i32>,
    owner_username: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelectedListContent {
    fn default() -> &'a SelectedListContent {
        <SelectedListContent as ::protobuf::Message>::default_instance()
    }
}

impl SelectedListContent {
    pub fn new() -> SelectedListContent {
        ::std::default::Default::default()
    }

    // optional bytes revision = 1;


    pub fn get_revision(&self) -> &[u8] {
        match self.revision.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_revision(&mut self) {
        self.revision.clear();
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.revision = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.revision.is_none() {
            self.revision.set_default();
        }
        self.revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 length = 2;


    pub fn get_length(&self) -> i32 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional .ListAttributes attributes = 3;


    pub fn get_attributes(&self) -> &super::playlist4meta::ListAttributes {
        self.attributes.as_ref().unwrap_or_else(|| super::playlist4meta::ListAttributes::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: super::playlist4meta::ListAttributes) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut super::playlist4meta::ListAttributes {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> super::playlist4meta::ListAttributes {
        self.attributes.take().unwrap_or_else(|| super::playlist4meta::ListAttributes::new())
    }

    // optional .ListChecksum checksum = 4;


    pub fn get_checksum(&self) -> &super::playlist4meta::ListChecksum {
        self.checksum.as_ref().unwrap_or_else(|| super::playlist4meta::ListChecksum::default_instance())
    }
    pub fn clear_checksum(&mut self) {
        self.checksum.clear();
    }

    pub fn has_checksum(&self) -> bool {
        self.checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: super::playlist4meta::ListChecksum) {
        self.checksum = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checksum(&mut self) -> &mut super::playlist4meta::ListChecksum {
        if self.checksum.is_none() {
            self.checksum.set_default();
        }
        self.checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_checksum(&mut self) -> super::playlist4meta::ListChecksum {
        self.checksum.take().unwrap_or_else(|| super::playlist4meta::ListChecksum::new())
    }

    // optional .ListItems contents = 5;


    pub fn get_contents(&self) -> &super::playlist4content::ListItems {
        self.contents.as_ref().unwrap_or_else(|| super::playlist4content::ListItems::default_instance())
    }
    pub fn clear_contents(&mut self) {
        self.contents.clear();
    }

    pub fn has_contents(&self) -> bool {
        self.contents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contents(&mut self, v: super::playlist4content::ListItems) {
        self.contents = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contents(&mut self) -> &mut super::playlist4content::ListItems {
        if self.contents.is_none() {
            self.contents.set_default();
        }
        self.contents.as_mut().unwrap()
    }

    // Take field
    pub fn take_contents(&mut self) -> super::playlist4content::ListItems {
        self.contents.take().unwrap_or_else(|| super::playlist4content::ListItems::new())
    }

    // optional .Diff diff = 6;


    pub fn get_diff(&self) -> &Diff {
        self.diff.as_ref().unwrap_or_else(|| Diff::default_instance())
    }
    pub fn clear_diff(&mut self) {
        self.diff.clear();
    }

    pub fn has_diff(&self) -> bool {
        self.diff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diff(&mut self, v: Diff) {
        self.diff = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diff(&mut self) -> &mut Diff {
        if self.diff.is_none() {
            self.diff.set_default();
        }
        self.diff.as_mut().unwrap()
    }

    // Take field
    pub fn take_diff(&mut self) -> Diff {
        self.diff.take().unwrap_or_else(|| Diff::new())
    }

    // optional .Diff syncResult = 7;


    pub fn get_syncResult(&self) -> &Diff {
        self.syncResult.as_ref().unwrap_or_else(|| Diff::default_instance())
    }
    pub fn clear_syncResult(&mut self) {
        self.syncResult.clear();
    }

    pub fn has_syncResult(&self) -> bool {
        self.syncResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syncResult(&mut self, v: Diff) {
        self.syncResult = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_syncResult(&mut self) -> &mut Diff {
        if self.syncResult.is_none() {
            self.syncResult.set_default();
        }
        self.syncResult.as_mut().unwrap()
    }

    // Take field
    pub fn take_syncResult(&mut self) -> Diff {
        self.syncResult.take().unwrap_or_else(|| Diff::new())
    }

    // repeated bytes resultingRevisions = 8;


    pub fn get_resultingRevisions(&self) -> &[::std::vec::Vec<u8>] {
        &self.resultingRevisions
    }
    pub fn clear_resultingRevisions(&mut self) {
        self.resultingRevisions.clear();
    }

    // Param is passed by value, moved
    pub fn set_resultingRevisions(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.resultingRevisions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resultingRevisions(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.resultingRevisions
    }

    // Take field
    pub fn take_resultingRevisions(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.resultingRevisions, ::protobuf::RepeatedField::new())
    }

    // optional bool multipleHeads = 9;


    pub fn get_multipleHeads(&self) -> bool {
        self.multipleHeads.unwrap_or(false)
    }
    pub fn clear_multipleHeads(&mut self) {
        self.multipleHeads = ::std::option::Option::None;
    }

    pub fn has_multipleHeads(&self) -> bool {
        self.multipleHeads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multipleHeads(&mut self, v: bool) {
        self.multipleHeads = ::std::option::Option::Some(v);
    }

    // optional bool upToDate = 10;


    pub fn get_upToDate(&self) -> bool {
        self.upToDate.unwrap_or(false)
    }
    pub fn clear_upToDate(&mut self) {
        self.upToDate = ::std::option::Option::None;
    }

    pub fn has_upToDate(&self) -> bool {
        self.upToDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upToDate(&mut self, v: bool) {
        self.upToDate = ::std::option::Option::Some(v);
    }

    // repeated .ClientResolveAction resolveAction = 12;


    pub fn get_resolveAction(&self) -> &[super::playlist4issues::ClientResolveAction] {
        &self.resolveAction
    }
    pub fn clear_resolveAction(&mut self) {
        self.resolveAction.clear();
    }

    // Param is passed by value, moved
    pub fn set_resolveAction(&mut self, v: ::protobuf::RepeatedField<super::playlist4issues::ClientResolveAction>) {
        self.resolveAction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resolveAction(&mut self) -> &mut ::protobuf::RepeatedField<super::playlist4issues::ClientResolveAction> {
        &mut self.resolveAction
    }

    // Take field
    pub fn take_resolveAction(&mut self) -> ::protobuf::RepeatedField<super::playlist4issues::ClientResolveAction> {
        ::std::mem::replace(&mut self.resolveAction, ::protobuf::RepeatedField::new())
    }

    // repeated .ClientIssue issues = 13;


    pub fn get_issues(&self) -> &[super::playlist4issues::ClientIssue] {
        &self.issues
    }
    pub fn clear_issues(&mut self) {
        self.issues.clear();
    }

    // Param is passed by value, moved
    pub fn set_issues(&mut self, v: ::protobuf::RepeatedField<super::playlist4issues::ClientIssue>) {
        self.issues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_issues(&mut self) -> &mut ::protobuf::RepeatedField<super::playlist4issues::ClientIssue> {
        &mut self.issues
    }

    // Take field
    pub fn take_issues(&mut self) -> ::protobuf::RepeatedField<super::playlist4issues::ClientIssue> {
        ::std::mem::replace(&mut self.issues, ::protobuf::RepeatedField::new())
    }

    // repeated int32 nonces = 14;


    pub fn get_nonces(&self) -> &[i32] {
        &self.nonces
    }
    pub fn clear_nonces(&mut self) {
        self.nonces.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonces(&mut self, v: ::std::vec::Vec<i32>) {
        self.nonces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nonces(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.nonces
    }

    // Take field
    pub fn take_nonces(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.nonces, ::std::vec::Vec::new())
    }

    // optional string owner_username = 16;


    pub fn get_owner_username(&self) -> &str {
        match self.owner_username.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_owner_username(&mut self) {
        self.owner_username.clear();
    }

    pub fn has_owner_username(&self) -> bool {
        self.owner_username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_username(&mut self, v: ::std::string::String) {
        self.owner_username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_username(&mut self) -> &mut ::std::string::String {
        if self.owner_username.is_none() {
            self.owner_username.set_default();
        }
        self.owner_username.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_username(&mut self) -> ::std::string::String {
        self.owner_username.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SelectedListContent {
    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checksum {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contents {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.diff {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.syncResult {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resolveAction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.issues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.revision)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checksum)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contents)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.diff)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.syncResult)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.resultingRevisions)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.multipleHeads = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.upToDate = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resolveAction)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.issues)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.nonces)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.owner_username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checksum.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.contents.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.diff.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.syncResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.resultingRevisions {
            my_size += ::protobuf::rt::bytes_size(8, &value);
        };
        if let Some(v) = self.multipleHeads {
            my_size += 2;
        }
        if let Some(v) = self.upToDate {
            my_size += 2;
        }
        for value in &self.resolveAction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.issues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.nonces {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.owner_username.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.revision.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.length {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checksum.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.contents.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.diff.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.syncResult.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.resultingRevisions {
            os.write_bytes(8, &v)?;
        };
        if let Some(v) = self.multipleHeads {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.upToDate {
            os.write_bool(10, v)?;
        }
        for v in &self.resolveAction {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.issues {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.nonces {
            os.write_int32(14, *v)?;
        };
        if let Some(ref v) = self.owner_username.as_ref() {
            os.write_string(16, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelectedListContent {
        SelectedListContent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "revision",
                    |m: &SelectedListContent| { &m.revision },
                    |m: &mut SelectedListContent| { &mut m.revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "length",
                    |m: &SelectedListContent| { &m.length },
                    |m: &mut SelectedListContent| { &mut m.length },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::playlist4meta::ListAttributes>>(
                    "attributes",
                    |m: &SelectedListContent| { &m.attributes },
                    |m: &mut SelectedListContent| { &mut m.attributes },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::playlist4meta::ListChecksum>>(
                    "checksum",
                    |m: &SelectedListContent| { &m.checksum },
                    |m: &mut SelectedListContent| { &mut m.checksum },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::playlist4content::ListItems>>(
                    "contents",
                    |m: &SelectedListContent| { &m.contents },
                    |m: &mut SelectedListContent| { &mut m.contents },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Diff>>(
                    "diff",
                    |m: &SelectedListContent| { &m.diff },
                    |m: &mut SelectedListContent| { &mut m.diff },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Diff>>(
                    "syncResult",
                    |m: &SelectedListContent| { &m.syncResult },
                    |m: &mut SelectedListContent| { &mut m.syncResult },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "resultingRevisions",
                    |m: &SelectedListContent| { &m.resultingRevisions },
                    |m: &mut SelectedListContent| { &mut m.resultingRevisions },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "multipleHeads",
                    |m: &SelectedListContent| { &m.multipleHeads },
                    |m: &mut SelectedListContent| { &mut m.multipleHeads },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "upToDate",
                    |m: &SelectedListContent| { &m.upToDate },
                    |m: &mut SelectedListContent| { &mut m.upToDate },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::playlist4issues::ClientResolveAction>>(
                    "resolveAction",
                    |m: &SelectedListContent| { &m.resolveAction },
                    |m: &mut SelectedListContent| { &mut m.resolveAction },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::playlist4issues::ClientIssue>>(
                    "issues",
                    |m: &SelectedListContent| { &m.issues },
                    |m: &mut SelectedListContent| { &mut m.issues },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "nonces",
                    |m: &SelectedListContent| { &m.nonces },
                    |m: &mut SelectedListContent| { &mut m.nonces },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "owner_username",
                    |m: &SelectedListContent| { &m.owner_username },
                    |m: &mut SelectedListContent| { &mut m.owner_username },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SelectedListContent>(
                    "SelectedListContent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SelectedListContent {
        static mut instance: ::protobuf::lazy::Lazy<SelectedListContent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SelectedListContent,
        };
        unsafe {
            instance.get(SelectedListContent::new)
        }
    }
}

impl ::protobuf::Clear for SelectedListContent {
    fn clear(&mut self) {
        self.revision.clear();
        self.length = ::std::option::Option::None;
        self.attributes.clear();
        self.checksum.clear();
        self.contents.clear();
        self.diff.clear();
        self.syncResult.clear();
        self.resultingRevisions.clear();
        self.multipleHeads = ::std::option::Option::None;
        self.upToDate = ::std::option::Option::None;
        self.resolveAction.clear();
        self.issues.clear();
        self.nonces.clear();
        self.owner_username.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelectedListContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectedListContent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16playlist4changes.proto\x12\0\"\xa0\x01\n\nChangeInfo\x12\x0e\n\x04\
    user\x18\x01\x20\x01(\tB\0\x12\x13\n\ttimestamp\x18\x02\x20\x01(\x05B\0\
    \x12\x0f\n\x05admin\x18\x03\x20\x01(\x08B\0\x12\x0e\n\x04undo\x18\x04\
    \x20\x01(\x08B\0\x12\x0e\n\x04redo\x18\x05\x20\x01(\x08B\0\x12\x0f\n\x05\
    merge\x18\x06\x20\x01(\x08B\0\x12\x14\n\ncompressed\x18\x07\x20\x01(\x08\
    B\0\x12\x13\n\tmigration\x18\x08\x20\x01(\x08B\0:\0\"R\n\x05Delta\x12\
    \x16\n\x0cbase_version\x18\x01\x20\x01(\x0cB\0\x12\x12\n\x03ops\x18\x02\
    \x20\x03(\x0b2\x03.OpB\0\x12\x1b\n\x04info\x18\x04\x20\x01(\x0b2\x0b.Cha\
    ngeInfoB\0:\0\"W\n\x05Merge\x12\x16\n\x0cbase_version\x18\x01\x20\x01(\
    \x0cB\0\x12\x17\n\rmerge_version\x18\x02\x20\x01(\x0cB\0\x12\x1b\n\x04in\
    fo\x18\x04\x20\x01(\x0b2\x0b.ChangeInfoB\0:\0\"\x92\x01\n\tChangeSet\x12\
    \x1f\n\x04kind\x18\x01\x20\x01(\x0e2\x0f.ChangeSet.KindB\0\x12\x17\n\x05\
    delta\x18\x02\x20\x01(\x0b2\x06.DeltaB\0\x12\x17\n\x05merge\x18\x03\x20\
    \x01(\x0b2\x06.MergeB\0\"0\n\x04Kind\x12\x10\n\x0cKIND_UNKNOWN\x10\0\x12\
    \t\n\x05DELTA\x10\x02\x12\t\n\x05MERGE\x10\x03\x1a\0:\0\"Q\n\x17Revision\
    TaggedChangeSet\x12\x12\n\x08revision\x18\x01\x20\x01(\x0cB\0\x12\x20\n\
    \nchange_set\x18\x02\x20\x01(\x0b2\n.ChangeSetB\0:\0\"L\n\x04Diff\x12\
    \x17\n\rfrom_revision\x18\x01\x20\x01(\x0cB\0\x12\x12\n\x03ops\x18\x02\
    \x20\x03(\x0b2\x03.OpB\0\x12\x15\n\x0bto_revision\x18\x03\x20\x01(\x0cB\
    \0:\0\"\xc3\x01\n\x08ListDump\x12\x18\n\x0elatestRevision\x18\x01\x20\
    \x01(\x0cB\0\x12\x10\n\x06length\x18\x02\x20\x01(\x05B\0\x12%\n\nattribu\
    tes\x18\x03\x20\x01(\x0b2\x0f.ListAttributesB\0\x12!\n\x08checksum\x18\
    \x04\x20\x01(\x0b2\r.ListChecksumB\0\x12\x1e\n\x08contents\x18\x05\x20\
    \x01(\x0b2\n.ListItemsB\0\x12\x1f\n\rpendingDeltas\x18\x07\x20\x03(\x0b2\
    \x06.DeltaB\0:\0\"\xaa\x01\n\x0bListChanges\x12\x16\n\x0cbaseRevision\
    \x18\x01\x20\x01(\x0cB\0\x12\x18\n\x06deltas\x18\x02\x20\x03(\x0b2\x06.D\
    eltaB\0\x12\x20\n\x16wantResultingRevisions\x18\x03\x20\x01(\x08B\0\x12\
    \x18\n\x0ewantSyncResult\x18\x04\x20\x01(\x08B\0\x12\x19\n\x04dump\x18\
    \x05\x20\x01(\x0b2\t.ListDumpB\0\x12\x10\n\x06nonces\x18\x06\x20\x03(\
    \x05B\0:\0\"\xa1\x03\n\x13SelectedListContent\x12\x12\n\x08revision\x18\
    \x01\x20\x01(\x0cB\0\x12\x10\n\x06length\x18\x02\x20\x01(\x05B\0\x12%\n\
    \nattributes\x18\x03\x20\x01(\x0b2\x0f.ListAttributesB\0\x12!\n\x08check\
    sum\x18\x04\x20\x01(\x0b2\r.ListChecksumB\0\x12\x1e\n\x08contents\x18\
    \x05\x20\x01(\x0b2\n.ListItemsB\0\x12\x15\n\x04diff\x18\x06\x20\x01(\x0b\
    2\x05.DiffB\0\x12\x1b\n\nsyncResult\x18\x07\x20\x01(\x0b2\x05.DiffB\0\
    \x12\x1c\n\x12resultingRevisions\x18\x08\x20\x03(\x0cB\0\x12\x17\n\rmult\
    ipleHeads\x18\t\x20\x01(\x08B\0\x12\x12\n\x08upToDate\x18\n\x20\x01(\x08\
    B\0\x12-\n\rresolveAction\x18\x0c\x20\x03(\x0b2\x14.ClientResolveActionB\
    \0\x12\x1e\n\x06issues\x18\r\x20\x03(\x0b2\x0c.ClientIssueB\0\x12\x10\n\
    \x06nonces\x18\x0e\x20\x03(\x05B\0\x12\x18\n\x0eowner_username\x18\x10\
    \x20\x01(\tB\0:\0B\0b\x06proto2\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
