// This file is generated by rust-protobuf 2.8.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `metadata.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_2;

#[derive(PartialEq,Clone,Default)]
pub struct TopTracks {
    // message fields
    country: ::protobuf::SingularField<::std::string::String>,
    track: ::protobuf::RepeatedField<Track>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TopTracks {
    fn default() -> &'a TopTracks {
        <TopTracks as ::protobuf::Message>::default_instance()
    }
}

impl TopTracks {
    pub fn new() -> TopTracks {
        ::std::default::Default::default()
    }

    // optional string country = 1;


    pub fn get_country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country(&mut self) {
        self.country.clear();
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country.set_default();
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .Track track = 2;


    pub fn get_track(&self) -> &[Track] {
        &self.track
    }
    pub fn clear_track(&mut self) {
        self.track.clear();
    }

    // Param is passed by value, moved
    pub fn set_track(&mut self, v: ::protobuf::RepeatedField<Track>) {
        self.track = v;
    }

    // Mutable pointer to the field.
    pub fn mut_track(&mut self) -> &mut ::protobuf::RepeatedField<Track> {
        &mut self.track
    }

    // Take field
    pub fn take_track(&mut self) -> ::protobuf::RepeatedField<Track> {
        ::std::mem::replace(&mut self.track, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TopTracks {
    fn is_initialized(&self) -> bool {
        for v in &self.track {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.track)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.track {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.country.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.track {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TopTracks {
        TopTracks::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "country",
                    |m: &TopTracks| { &m.country },
                    |m: &mut TopTracks| { &mut m.country },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Track>>(
                    "track",
                    |m: &TopTracks| { &m.track },
                    |m: &mut TopTracks| { &mut m.track },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TopTracks>(
                    "TopTracks",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TopTracks {
        static mut instance: ::protobuf::lazy::Lazy<TopTracks> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TopTracks,
        };
        unsafe {
            instance.get(TopTracks::new)
        }
    }
}

impl ::protobuf::Clear for TopTracks {
    fn clear(&mut self) {
        self.country.clear();
        self.track.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TopTracks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TopTracks {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActivityPeriod {
    // message fields
    start_year: ::std::option::Option<i32>,
    end_year: ::std::option::Option<i32>,
    decade: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActivityPeriod {
    fn default() -> &'a ActivityPeriod {
        <ActivityPeriod as ::protobuf::Message>::default_instance()
    }
}

impl ActivityPeriod {
    pub fn new() -> ActivityPeriod {
        ::std::default::Default::default()
    }

    // optional sint32 start_year = 1;


    pub fn get_start_year(&self) -> i32 {
        self.start_year.unwrap_or(0)
    }
    pub fn clear_start_year(&mut self) {
        self.start_year = ::std::option::Option::None;
    }

    pub fn has_start_year(&self) -> bool {
        self.start_year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_year(&mut self, v: i32) {
        self.start_year = ::std::option::Option::Some(v);
    }

    // optional sint32 end_year = 2;


    pub fn get_end_year(&self) -> i32 {
        self.end_year.unwrap_or(0)
    }
    pub fn clear_end_year(&mut self) {
        self.end_year = ::std::option::Option::None;
    }

    pub fn has_end_year(&self) -> bool {
        self.end_year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_year(&mut self, v: i32) {
        self.end_year = ::std::option::Option::Some(v);
    }

    // optional sint32 decade = 3;


    pub fn get_decade(&self) -> i32 {
        self.decade.unwrap_or(0)
    }
    pub fn clear_decade(&mut self) {
        self.decade = ::std::option::Option::None;
    }

    pub fn has_decade(&self) -> bool {
        self.decade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decade(&mut self, v: i32) {
        self.decade = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActivityPeriod {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.start_year = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.end_year = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.decade = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.start_year {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        if let Some(v) = self.end_year {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        if let Some(v) = self.decade {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.start_year {
            os.write_sint32(1, v)?;
        }
        if let Some(v) = self.end_year {
            os.write_sint32(2, v)?;
        }
        if let Some(v) = self.decade {
            os.write_sint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActivityPeriod {
        ActivityPeriod::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "start_year",
                    |m: &ActivityPeriod| { &m.start_year },
                    |m: &mut ActivityPeriod| { &mut m.start_year },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "end_year",
                    |m: &ActivityPeriod| { &m.end_year },
                    |m: &mut ActivityPeriod| { &mut m.end_year },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "decade",
                    |m: &ActivityPeriod| { &m.decade },
                    |m: &mut ActivityPeriod| { &mut m.decade },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActivityPeriod>(
                    "ActivityPeriod",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActivityPeriod {
        static mut instance: ::protobuf::lazy::Lazy<ActivityPeriod> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActivityPeriod,
        };
        unsafe {
            instance.get(ActivityPeriod::new)
        }
    }
}

impl ::protobuf::Clear for ActivityPeriod {
    fn clear(&mut self) {
        self.start_year = ::std::option::Option::None;
        self.end_year = ::std::option::Option::None;
        self.decade = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActivityPeriod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivityPeriod {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Artist {
    // message fields
    gid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    name: ::protobuf::SingularField<::std::string::String>,
    popularity: ::std::option::Option<i32>,
    top_track: ::protobuf::RepeatedField<TopTracks>,
    album_group: ::protobuf::RepeatedField<AlbumGroup>,
    single_group: ::protobuf::RepeatedField<AlbumGroup>,
    compilation_group: ::protobuf::RepeatedField<AlbumGroup>,
    appears_on_group: ::protobuf::RepeatedField<AlbumGroup>,
    genre: ::protobuf::RepeatedField<::std::string::String>,
    external_id: ::protobuf::RepeatedField<ExternalId>,
    portrait: ::protobuf::RepeatedField<Image>,
    biography: ::protobuf::RepeatedField<Biography>,
    activity_period: ::protobuf::RepeatedField<ActivityPeriod>,
    restriction: ::protobuf::RepeatedField<Restriction>,
    related: ::protobuf::RepeatedField<Artist>,
    is_portrait_album_cover: ::std::option::Option<bool>,
    portrait_group: ::protobuf::SingularPtrField<ImageGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Artist {
    fn default() -> &'a Artist {
        <Artist as ::protobuf::Message>::default_instance()
    }
}

impl Artist {
    pub fn new() -> Artist {
        ::std::default::Default::default()
    }

    // optional bytes gid = 1;


    pub fn get_gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_gid(&mut self) {
        self.gid.clear();
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid.set_default();
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint32 popularity = 3;


    pub fn get_popularity(&self) -> i32 {
        self.popularity.unwrap_or(0)
    }
    pub fn clear_popularity(&mut self) {
        self.popularity = ::std::option::Option::None;
    }

    pub fn has_popularity(&self) -> bool {
        self.popularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_popularity(&mut self, v: i32) {
        self.popularity = ::std::option::Option::Some(v);
    }

    // repeated .TopTracks top_track = 4;


    pub fn get_top_track(&self) -> &[TopTracks] {
        &self.top_track
    }
    pub fn clear_top_track(&mut self) {
        self.top_track.clear();
    }

    // Param is passed by value, moved
    pub fn set_top_track(&mut self, v: ::protobuf::RepeatedField<TopTracks>) {
        self.top_track = v;
    }

    // Mutable pointer to the field.
    pub fn mut_top_track(&mut self) -> &mut ::protobuf::RepeatedField<TopTracks> {
        &mut self.top_track
    }

    // Take field
    pub fn take_top_track(&mut self) -> ::protobuf::RepeatedField<TopTracks> {
        ::std::mem::replace(&mut self.top_track, ::protobuf::RepeatedField::new())
    }

    // repeated .AlbumGroup album_group = 5;


    pub fn get_album_group(&self) -> &[AlbumGroup] {
        &self.album_group
    }
    pub fn clear_album_group(&mut self) {
        self.album_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_album_group(&mut self, v: ::protobuf::RepeatedField<AlbumGroup>) {
        self.album_group = v;
    }

    // Mutable pointer to the field.
    pub fn mut_album_group(&mut self) -> &mut ::protobuf::RepeatedField<AlbumGroup> {
        &mut self.album_group
    }

    // Take field
    pub fn take_album_group(&mut self) -> ::protobuf::RepeatedField<AlbumGroup> {
        ::std::mem::replace(&mut self.album_group, ::protobuf::RepeatedField::new())
    }

    // repeated .AlbumGroup single_group = 6;


    pub fn get_single_group(&self) -> &[AlbumGroup] {
        &self.single_group
    }
    pub fn clear_single_group(&mut self) {
        self.single_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_single_group(&mut self, v: ::protobuf::RepeatedField<AlbumGroup>) {
        self.single_group = v;
    }

    // Mutable pointer to the field.
    pub fn mut_single_group(&mut self) -> &mut ::protobuf::RepeatedField<AlbumGroup> {
        &mut self.single_group
    }

    // Take field
    pub fn take_single_group(&mut self) -> ::protobuf::RepeatedField<AlbumGroup> {
        ::std::mem::replace(&mut self.single_group, ::protobuf::RepeatedField::new())
    }

    // repeated .AlbumGroup compilation_group = 7;


    pub fn get_compilation_group(&self) -> &[AlbumGroup] {
        &self.compilation_group
    }
    pub fn clear_compilation_group(&mut self) {
        self.compilation_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_compilation_group(&mut self, v: ::protobuf::RepeatedField<AlbumGroup>) {
        self.compilation_group = v;
    }

    // Mutable pointer to the field.
    pub fn mut_compilation_group(&mut self) -> &mut ::protobuf::RepeatedField<AlbumGroup> {
        &mut self.compilation_group
    }

    // Take field
    pub fn take_compilation_group(&mut self) -> ::protobuf::RepeatedField<AlbumGroup> {
        ::std::mem::replace(&mut self.compilation_group, ::protobuf::RepeatedField::new())
    }

    // repeated .AlbumGroup appears_on_group = 8;


    pub fn get_appears_on_group(&self) -> &[AlbumGroup] {
        &self.appears_on_group
    }
    pub fn clear_appears_on_group(&mut self) {
        self.appears_on_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_appears_on_group(&mut self, v: ::protobuf::RepeatedField<AlbumGroup>) {
        self.appears_on_group = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appears_on_group(&mut self) -> &mut ::protobuf::RepeatedField<AlbumGroup> {
        &mut self.appears_on_group
    }

    // Take field
    pub fn take_appears_on_group(&mut self) -> ::protobuf::RepeatedField<AlbumGroup> {
        ::std::mem::replace(&mut self.appears_on_group, ::protobuf::RepeatedField::new())
    }

    // repeated string genre = 9;


    pub fn get_genre(&self) -> &[::std::string::String] {
        &self.genre
    }
    pub fn clear_genre(&mut self) {
        self.genre.clear();
    }

    // Param is passed by value, moved
    pub fn set_genre(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.genre = v;
    }

    // Mutable pointer to the field.
    pub fn mut_genre(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.genre
    }

    // Take field
    pub fn take_genre(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.genre, ::protobuf::RepeatedField::new())
    }

    // repeated .ExternalId external_id = 10;


    pub fn get_external_id(&self) -> &[ExternalId] {
        &self.external_id
    }
    pub fn clear_external_id(&mut self) {
        self.external_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_external_id(&mut self, v: ::protobuf::RepeatedField<ExternalId>) {
        self.external_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_external_id(&mut self) -> &mut ::protobuf::RepeatedField<ExternalId> {
        &mut self.external_id
    }

    // Take field
    pub fn take_external_id(&mut self) -> ::protobuf::RepeatedField<ExternalId> {
        ::std::mem::replace(&mut self.external_id, ::protobuf::RepeatedField::new())
    }

    // repeated .Image portrait = 11;


    pub fn get_portrait(&self) -> &[Image] {
        &self.portrait
    }
    pub fn clear_portrait(&mut self) {
        self.portrait.clear();
    }

    // Param is passed by value, moved
    pub fn set_portrait(&mut self, v: ::protobuf::RepeatedField<Image>) {
        self.portrait = v;
    }

    // Mutable pointer to the field.
    pub fn mut_portrait(&mut self) -> &mut ::protobuf::RepeatedField<Image> {
        &mut self.portrait
    }

    // Take field
    pub fn take_portrait(&mut self) -> ::protobuf::RepeatedField<Image> {
        ::std::mem::replace(&mut self.portrait, ::protobuf::RepeatedField::new())
    }

    // repeated .Biography biography = 12;


    pub fn get_biography(&self) -> &[Biography] {
        &self.biography
    }
    pub fn clear_biography(&mut self) {
        self.biography.clear();
    }

    // Param is passed by value, moved
    pub fn set_biography(&mut self, v: ::protobuf::RepeatedField<Biography>) {
        self.biography = v;
    }

    // Mutable pointer to the field.
    pub fn mut_biography(&mut self) -> &mut ::protobuf::RepeatedField<Biography> {
        &mut self.biography
    }

    // Take field
    pub fn take_biography(&mut self) -> ::protobuf::RepeatedField<Biography> {
        ::std::mem::replace(&mut self.biography, ::protobuf::RepeatedField::new())
    }

    // repeated .ActivityPeriod activity_period = 13;


    pub fn get_activity_period(&self) -> &[ActivityPeriod] {
        &self.activity_period
    }
    pub fn clear_activity_period(&mut self) {
        self.activity_period.clear();
    }

    // Param is passed by value, moved
    pub fn set_activity_period(&mut self, v: ::protobuf::RepeatedField<ActivityPeriod>) {
        self.activity_period = v;
    }

    // Mutable pointer to the field.
    pub fn mut_activity_period(&mut self) -> &mut ::protobuf::RepeatedField<ActivityPeriod> {
        &mut self.activity_period
    }

    // Take field
    pub fn take_activity_period(&mut self) -> ::protobuf::RepeatedField<ActivityPeriod> {
        ::std::mem::replace(&mut self.activity_period, ::protobuf::RepeatedField::new())
    }

    // repeated .Restriction restriction = 14;


    pub fn get_restriction(&self) -> &[Restriction] {
        &self.restriction
    }
    pub fn clear_restriction(&mut self) {
        self.restriction.clear();
    }

    // Param is passed by value, moved
    pub fn set_restriction(&mut self, v: ::protobuf::RepeatedField<Restriction>) {
        self.restriction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_restriction(&mut self) -> &mut ::protobuf::RepeatedField<Restriction> {
        &mut self.restriction
    }

    // Take field
    pub fn take_restriction(&mut self) -> ::protobuf::RepeatedField<Restriction> {
        ::std::mem::replace(&mut self.restriction, ::protobuf::RepeatedField::new())
    }

    // repeated .Artist related = 15;


    pub fn get_related(&self) -> &[Artist] {
        &self.related
    }
    pub fn clear_related(&mut self) {
        self.related.clear();
    }

    // Param is passed by value, moved
    pub fn set_related(&mut self, v: ::protobuf::RepeatedField<Artist>) {
        self.related = v;
    }

    // Mutable pointer to the field.
    pub fn mut_related(&mut self) -> &mut ::protobuf::RepeatedField<Artist> {
        &mut self.related
    }

    // Take field
    pub fn take_related(&mut self) -> ::protobuf::RepeatedField<Artist> {
        ::std::mem::replace(&mut self.related, ::protobuf::RepeatedField::new())
    }

    // optional bool is_portrait_album_cover = 16;


    pub fn get_is_portrait_album_cover(&self) -> bool {
        self.is_portrait_album_cover.unwrap_or(false)
    }
    pub fn clear_is_portrait_album_cover(&mut self) {
        self.is_portrait_album_cover = ::std::option::Option::None;
    }

    pub fn has_is_portrait_album_cover(&self) -> bool {
        self.is_portrait_album_cover.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_portrait_album_cover(&mut self, v: bool) {
        self.is_portrait_album_cover = ::std::option::Option::Some(v);
    }

    // optional .ImageGroup portrait_group = 17;


    pub fn get_portrait_group(&self) -> &ImageGroup {
        self.portrait_group.as_ref().unwrap_or_else(|| ImageGroup::default_instance())
    }
    pub fn clear_portrait_group(&mut self) {
        self.portrait_group.clear();
    }

    pub fn has_portrait_group(&self) -> bool {
        self.portrait_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portrait_group(&mut self, v: ImageGroup) {
        self.portrait_group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portrait_group(&mut self) -> &mut ImageGroup {
        if self.portrait_group.is_none() {
            self.portrait_group.set_default();
        }
        self.portrait_group.as_mut().unwrap()
    }

    // Take field
    pub fn take_portrait_group(&mut self) -> ImageGroup {
        self.portrait_group.take().unwrap_or_else(|| ImageGroup::new())
    }
}

impl ::protobuf::Message for Artist {
    fn is_initialized(&self) -> bool {
        for v in &self.top_track {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.album_group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.single_group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.compilation_group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appears_on_group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.external_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.portrait {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.biography {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activity_period {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restriction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.related {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.portrait_group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.gid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.popularity = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.top_track)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.album_group)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.single_group)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.compilation_group)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.appears_on_group)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.genre)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.external_id)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.portrait)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.biography)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.activity_period)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.restriction)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.related)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_portrait_album_cover = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.portrait_group)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.popularity {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        for value in &self.top_track {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.album_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.single_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.compilation_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.appears_on_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.genre {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.external_id {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.portrait {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.biography {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.activity_period {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.restriction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.related {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.is_portrait_album_cover {
            my_size += 3;
        }
        if let Some(ref v) = self.portrait_group.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gid.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.popularity {
            os.write_sint32(3, v)?;
        }
        for v in &self.top_track {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.album_group {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.single_group {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.compilation_group {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.appears_on_group {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.genre {
            os.write_string(9, &v)?;
        };
        for v in &self.external_id {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.portrait {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.biography {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.activity_period {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.restriction {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.related {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.is_portrait_album_cover {
            os.write_bool(16, v)?;
        }
        if let Some(ref v) = self.portrait_group.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Artist {
        Artist::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gid",
                    |m: &Artist| { &m.gid },
                    |m: &mut Artist| { &mut m.gid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Artist| { &m.name },
                    |m: &mut Artist| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "popularity",
                    |m: &Artist| { &m.popularity },
                    |m: &mut Artist| { &mut m.popularity },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TopTracks>>(
                    "top_track",
                    |m: &Artist| { &m.top_track },
                    |m: &mut Artist| { &mut m.top_track },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlbumGroup>>(
                    "album_group",
                    |m: &Artist| { &m.album_group },
                    |m: &mut Artist| { &mut m.album_group },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlbumGroup>>(
                    "single_group",
                    |m: &Artist| { &m.single_group },
                    |m: &mut Artist| { &mut m.single_group },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlbumGroup>>(
                    "compilation_group",
                    |m: &Artist| { &m.compilation_group },
                    |m: &mut Artist| { &mut m.compilation_group },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlbumGroup>>(
                    "appears_on_group",
                    |m: &Artist| { &m.appears_on_group },
                    |m: &mut Artist| { &mut m.appears_on_group },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "genre",
                    |m: &Artist| { &m.genre },
                    |m: &mut Artist| { &mut m.genre },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalId>>(
                    "external_id",
                    |m: &Artist| { &m.external_id },
                    |m: &mut Artist| { &mut m.external_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                    "portrait",
                    |m: &Artist| { &m.portrait },
                    |m: &mut Artist| { &mut m.portrait },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Biography>>(
                    "biography",
                    |m: &Artist| { &m.biography },
                    |m: &mut Artist| { &mut m.biography },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActivityPeriod>>(
                    "activity_period",
                    |m: &Artist| { &m.activity_period },
                    |m: &mut Artist| { &mut m.activity_period },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Restriction>>(
                    "restriction",
                    |m: &Artist| { &m.restriction },
                    |m: &mut Artist| { &mut m.restriction },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Artist>>(
                    "related",
                    |m: &Artist| { &m.related },
                    |m: &mut Artist| { &mut m.related },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_portrait_album_cover",
                    |m: &Artist| { &m.is_portrait_album_cover },
                    |m: &mut Artist| { &mut m.is_portrait_album_cover },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageGroup>>(
                    "portrait_group",
                    |m: &Artist| { &m.portrait_group },
                    |m: &mut Artist| { &mut m.portrait_group },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Artist>(
                    "Artist",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Artist {
        static mut instance: ::protobuf::lazy::Lazy<Artist> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Artist,
        };
        unsafe {
            instance.get(Artist::new)
        }
    }
}

impl ::protobuf::Clear for Artist {
    fn clear(&mut self) {
        self.gid.clear();
        self.name.clear();
        self.popularity = ::std::option::Option::None;
        self.top_track.clear();
        self.album_group.clear();
        self.single_group.clear();
        self.compilation_group.clear();
        self.appears_on_group.clear();
        self.genre.clear();
        self.external_id.clear();
        self.portrait.clear();
        self.biography.clear();
        self.activity_period.clear();
        self.restriction.clear();
        self.related.clear();
        self.is_portrait_album_cover = ::std::option::Option::None;
        self.portrait_group.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Artist {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Artist {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlbumGroup {
    // message fields
    album: ::protobuf::RepeatedField<Album>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlbumGroup {
    fn default() -> &'a AlbumGroup {
        <AlbumGroup as ::protobuf::Message>::default_instance()
    }
}

impl AlbumGroup {
    pub fn new() -> AlbumGroup {
        ::std::default::Default::default()
    }

    // repeated .Album album = 1;


    pub fn get_album(&self) -> &[Album] {
        &self.album
    }
    pub fn clear_album(&mut self) {
        self.album.clear();
    }

    // Param is passed by value, moved
    pub fn set_album(&mut self, v: ::protobuf::RepeatedField<Album>) {
        self.album = v;
    }

    // Mutable pointer to the field.
    pub fn mut_album(&mut self) -> &mut ::protobuf::RepeatedField<Album> {
        &mut self.album
    }

    // Take field
    pub fn take_album(&mut self) -> ::protobuf::RepeatedField<Album> {
        ::std::mem::replace(&mut self.album, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AlbumGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.album {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.album)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.album {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.album {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlbumGroup {
        AlbumGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Album>>(
                    "album",
                    |m: &AlbumGroup| { &m.album },
                    |m: &mut AlbumGroup| { &mut m.album },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AlbumGroup>(
                    "AlbumGroup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AlbumGroup {
        static mut instance: ::protobuf::lazy::Lazy<AlbumGroup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AlbumGroup,
        };
        unsafe {
            instance.get(AlbumGroup::new)
        }
    }
}

impl ::protobuf::Clear for AlbumGroup {
    fn clear(&mut self) {
        self.album.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlbumGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlbumGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Date {
    // message fields
    year: ::std::option::Option<i32>,
    month: ::std::option::Option<i32>,
    day: ::std::option::Option<i32>,
    hour: ::std::option::Option<i32>,
    minute: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Date {
    fn default() -> &'a Date {
        <Date as ::protobuf::Message>::default_instance()
    }
}

impl Date {
    pub fn new() -> Date {
        ::std::default::Default::default()
    }

    // optional sint32 year = 1;


    pub fn get_year(&self) -> i32 {
        self.year.unwrap_or(0)
    }
    pub fn clear_year(&mut self) {
        self.year = ::std::option::Option::None;
    }

    pub fn has_year(&self) -> bool {
        self.year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_year(&mut self, v: i32) {
        self.year = ::std::option::Option::Some(v);
    }

    // optional sint32 month = 2;


    pub fn get_month(&self) -> i32 {
        self.month.unwrap_or(0)
    }
    pub fn clear_month(&mut self) {
        self.month = ::std::option::Option::None;
    }

    pub fn has_month(&self) -> bool {
        self.month.is_some()
    }

    // Param is passed by value, moved
    pub fn set_month(&mut self, v: i32) {
        self.month = ::std::option::Option::Some(v);
    }

    // optional sint32 day = 3;


    pub fn get_day(&self) -> i32 {
        self.day.unwrap_or(0)
    }
    pub fn clear_day(&mut self) {
        self.day = ::std::option::Option::None;
    }

    pub fn has_day(&self) -> bool {
        self.day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_day(&mut self, v: i32) {
        self.day = ::std::option::Option::Some(v);
    }

    // optional sint32 hour = 4;


    pub fn get_hour(&self) -> i32 {
        self.hour.unwrap_or(0)
    }
    pub fn clear_hour(&mut self) {
        self.hour = ::std::option::Option::None;
    }

    pub fn has_hour(&self) -> bool {
        self.hour.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hour(&mut self, v: i32) {
        self.hour = ::std::option::Option::Some(v);
    }

    // optional sint32 minute = 5;


    pub fn get_minute(&self) -> i32 {
        self.minute.unwrap_or(0)
    }
    pub fn clear_minute(&mut self) {
        self.minute = ::std::option::Option::None;
    }

    pub fn has_minute(&self) -> bool {
        self.minute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minute(&mut self, v: i32) {
        self.minute = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Date {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.year = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.month = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.day = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.hour = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.minute = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.year {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        if let Some(v) = self.month {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        if let Some(v) = self.day {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(v) = self.hour {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, v);
        }
        if let Some(v) = self.minute {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.year {
            os.write_sint32(1, v)?;
        }
        if let Some(v) = self.month {
            os.write_sint32(2, v)?;
        }
        if let Some(v) = self.day {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.hour {
            os.write_sint32(4, v)?;
        }
        if let Some(v) = self.minute {
            os.write_sint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Date {
        Date::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "year",
                    |m: &Date| { &m.year },
                    |m: &mut Date| { &mut m.year },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "month",
                    |m: &Date| { &m.month },
                    |m: &mut Date| { &mut m.month },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "day",
                    |m: &Date| { &m.day },
                    |m: &mut Date| { &mut m.day },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "hour",
                    |m: &Date| { &m.hour },
                    |m: &mut Date| { &mut m.hour },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "minute",
                    |m: &Date| { &m.minute },
                    |m: &mut Date| { &mut m.minute },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Date>(
                    "Date",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Date {
        static mut instance: ::protobuf::lazy::Lazy<Date> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Date,
        };
        unsafe {
            instance.get(Date::new)
        }
    }
}

impl ::protobuf::Clear for Date {
    fn clear(&mut self) {
        self.year = ::std::option::Option::None;
        self.month = ::std::option::Option::None;
        self.day = ::std::option::Option::None;
        self.hour = ::std::option::Option::None;
        self.minute = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Date {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Date {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Album {
    // message fields
    gid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    name: ::protobuf::SingularField<::std::string::String>,
    artist: ::protobuf::RepeatedField<Artist>,
    typ: ::std::option::Option<Album_Type>,
    label: ::protobuf::SingularField<::std::string::String>,
    date: ::protobuf::SingularPtrField<Date>,
    popularity: ::std::option::Option<i32>,
    genre: ::protobuf::RepeatedField<::std::string::String>,
    cover: ::protobuf::RepeatedField<Image>,
    external_id: ::protobuf::RepeatedField<ExternalId>,
    disc: ::protobuf::RepeatedField<Disc>,
    review: ::protobuf::RepeatedField<::std::string::String>,
    copyright: ::protobuf::RepeatedField<Copyright>,
    restriction: ::protobuf::RepeatedField<Restriction>,
    related: ::protobuf::RepeatedField<Album>,
    sale_period: ::protobuf::RepeatedField<SalePeriod>,
    cover_group: ::protobuf::SingularPtrField<ImageGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Album {
    fn default() -> &'a Album {
        <Album as ::protobuf::Message>::default_instance()
    }
}

impl Album {
    pub fn new() -> Album {
        ::std::default::Default::default()
    }

    // optional bytes gid = 1;


    pub fn get_gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_gid(&mut self) {
        self.gid.clear();
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid.set_default();
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .Artist artist = 3;


    pub fn get_artist(&self) -> &[Artist] {
        &self.artist
    }
    pub fn clear_artist(&mut self) {
        self.artist.clear();
    }

    // Param is passed by value, moved
    pub fn set_artist(&mut self, v: ::protobuf::RepeatedField<Artist>) {
        self.artist = v;
    }

    // Mutable pointer to the field.
    pub fn mut_artist(&mut self) -> &mut ::protobuf::RepeatedField<Artist> {
        &mut self.artist
    }

    // Take field
    pub fn take_artist(&mut self) -> ::protobuf::RepeatedField<Artist> {
        ::std::mem::replace(&mut self.artist, ::protobuf::RepeatedField::new())
    }

    // optional .Album.Type typ = 4;


    pub fn get_typ(&self) -> Album_Type {
        self.typ.unwrap_or(Album_Type::ALBUM)
    }
    pub fn clear_typ(&mut self) {
        self.typ = ::std::option::Option::None;
    }

    pub fn has_typ(&self) -> bool {
        self.typ.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typ(&mut self, v: Album_Type) {
        self.typ = ::std::option::Option::Some(v);
    }

    // optional string label = 5;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .Date date = 6;


    pub fn get_date(&self) -> &Date {
        self.date.as_ref().unwrap_or_else(|| Date::default_instance())
    }
    pub fn clear_date(&mut self) {
        self.date.clear();
    }

    pub fn has_date(&self) -> bool {
        self.date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: Date) {
        self.date = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_date(&mut self) -> &mut Date {
        if self.date.is_none() {
            self.date.set_default();
        }
        self.date.as_mut().unwrap()
    }

    // Take field
    pub fn take_date(&mut self) -> Date {
        self.date.take().unwrap_or_else(|| Date::new())
    }

    // optional sint32 popularity = 7;


    pub fn get_popularity(&self) -> i32 {
        self.popularity.unwrap_or(0)
    }
    pub fn clear_popularity(&mut self) {
        self.popularity = ::std::option::Option::None;
    }

    pub fn has_popularity(&self) -> bool {
        self.popularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_popularity(&mut self, v: i32) {
        self.popularity = ::std::option::Option::Some(v);
    }

    // repeated string genre = 8;


    pub fn get_genre(&self) -> &[::std::string::String] {
        &self.genre
    }
    pub fn clear_genre(&mut self) {
        self.genre.clear();
    }

    // Param is passed by value, moved
    pub fn set_genre(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.genre = v;
    }

    // Mutable pointer to the field.
    pub fn mut_genre(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.genre
    }

    // Take field
    pub fn take_genre(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.genre, ::protobuf::RepeatedField::new())
    }

    // repeated .Image cover = 9;


    pub fn get_cover(&self) -> &[Image] {
        &self.cover
    }
    pub fn clear_cover(&mut self) {
        self.cover.clear();
    }

    // Param is passed by value, moved
    pub fn set_cover(&mut self, v: ::protobuf::RepeatedField<Image>) {
        self.cover = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cover(&mut self) -> &mut ::protobuf::RepeatedField<Image> {
        &mut self.cover
    }

    // Take field
    pub fn take_cover(&mut self) -> ::protobuf::RepeatedField<Image> {
        ::std::mem::replace(&mut self.cover, ::protobuf::RepeatedField::new())
    }

    // repeated .ExternalId external_id = 10;


    pub fn get_external_id(&self) -> &[ExternalId] {
        &self.external_id
    }
    pub fn clear_external_id(&mut self) {
        self.external_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_external_id(&mut self, v: ::protobuf::RepeatedField<ExternalId>) {
        self.external_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_external_id(&mut self) -> &mut ::protobuf::RepeatedField<ExternalId> {
        &mut self.external_id
    }

    // Take field
    pub fn take_external_id(&mut self) -> ::protobuf::RepeatedField<ExternalId> {
        ::std::mem::replace(&mut self.external_id, ::protobuf::RepeatedField::new())
    }

    // repeated .Disc disc = 11;


    pub fn get_disc(&self) -> &[Disc] {
        &self.disc
    }
    pub fn clear_disc(&mut self) {
        self.disc.clear();
    }

    // Param is passed by value, moved
    pub fn set_disc(&mut self, v: ::protobuf::RepeatedField<Disc>) {
        self.disc = v;
    }

    // Mutable pointer to the field.
    pub fn mut_disc(&mut self) -> &mut ::protobuf::RepeatedField<Disc> {
        &mut self.disc
    }

    // Take field
    pub fn take_disc(&mut self) -> ::protobuf::RepeatedField<Disc> {
        ::std::mem::replace(&mut self.disc, ::protobuf::RepeatedField::new())
    }

    // repeated string review = 12;


    pub fn get_review(&self) -> &[::std::string::String] {
        &self.review
    }
    pub fn clear_review(&mut self) {
        self.review.clear();
    }

    // Param is passed by value, moved
    pub fn set_review(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.review = v;
    }

    // Mutable pointer to the field.
    pub fn mut_review(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.review
    }

    // Take field
    pub fn take_review(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.review, ::protobuf::RepeatedField::new())
    }

    // repeated .Copyright copyright = 13;


    pub fn get_copyright(&self) -> &[Copyright] {
        &self.copyright
    }
    pub fn clear_copyright(&mut self) {
        self.copyright.clear();
    }

    // Param is passed by value, moved
    pub fn set_copyright(&mut self, v: ::protobuf::RepeatedField<Copyright>) {
        self.copyright = v;
    }

    // Mutable pointer to the field.
    pub fn mut_copyright(&mut self) -> &mut ::protobuf::RepeatedField<Copyright> {
        &mut self.copyright
    }

    // Take field
    pub fn take_copyright(&mut self) -> ::protobuf::RepeatedField<Copyright> {
        ::std::mem::replace(&mut self.copyright, ::protobuf::RepeatedField::new())
    }

    // repeated .Restriction restriction = 14;


    pub fn get_restriction(&self) -> &[Restriction] {
        &self.restriction
    }
    pub fn clear_restriction(&mut self) {
        self.restriction.clear();
    }

    // Param is passed by value, moved
    pub fn set_restriction(&mut self, v: ::protobuf::RepeatedField<Restriction>) {
        self.restriction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_restriction(&mut self) -> &mut ::protobuf::RepeatedField<Restriction> {
        &mut self.restriction
    }

    // Take field
    pub fn take_restriction(&mut self) -> ::protobuf::RepeatedField<Restriction> {
        ::std::mem::replace(&mut self.restriction, ::protobuf::RepeatedField::new())
    }

    // repeated .Album related = 15;


    pub fn get_related(&self) -> &[Album] {
        &self.related
    }
    pub fn clear_related(&mut self) {
        self.related.clear();
    }

    // Param is passed by value, moved
    pub fn set_related(&mut self, v: ::protobuf::RepeatedField<Album>) {
        self.related = v;
    }

    // Mutable pointer to the field.
    pub fn mut_related(&mut self) -> &mut ::protobuf::RepeatedField<Album> {
        &mut self.related
    }

    // Take field
    pub fn take_related(&mut self) -> ::protobuf::RepeatedField<Album> {
        ::std::mem::replace(&mut self.related, ::protobuf::RepeatedField::new())
    }

    // repeated .SalePeriod sale_period = 16;


    pub fn get_sale_period(&self) -> &[SalePeriod] {
        &self.sale_period
    }
    pub fn clear_sale_period(&mut self) {
        self.sale_period.clear();
    }

    // Param is passed by value, moved
    pub fn set_sale_period(&mut self, v: ::protobuf::RepeatedField<SalePeriod>) {
        self.sale_period = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sale_period(&mut self) -> &mut ::protobuf::RepeatedField<SalePeriod> {
        &mut self.sale_period
    }

    // Take field
    pub fn take_sale_period(&mut self) -> ::protobuf::RepeatedField<SalePeriod> {
        ::std::mem::replace(&mut self.sale_period, ::protobuf::RepeatedField::new())
    }

    // optional .ImageGroup cover_group = 17;


    pub fn get_cover_group(&self) -> &ImageGroup {
        self.cover_group.as_ref().unwrap_or_else(|| ImageGroup::default_instance())
    }
    pub fn clear_cover_group(&mut self) {
        self.cover_group.clear();
    }

    pub fn has_cover_group(&self) -> bool {
        self.cover_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cover_group(&mut self, v: ImageGroup) {
        self.cover_group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cover_group(&mut self) -> &mut ImageGroup {
        if self.cover_group.is_none() {
            self.cover_group.set_default();
        }
        self.cover_group.as_mut().unwrap()
    }

    // Take field
    pub fn take_cover_group(&mut self) -> ImageGroup {
        self.cover_group.take().unwrap_or_else(|| ImageGroup::new())
    }
}

impl ::protobuf::Message for Album {
    fn is_initialized(&self) -> bool {
        for v in &self.artist {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.date {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cover {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.external_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.disc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.copyright {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restriction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.related {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sale_period {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cover_group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.gid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.artist)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.typ, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.date)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.popularity = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.genre)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cover)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.external_id)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.disc)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.review)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.copyright)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.restriction)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.related)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sale_period)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cover_group)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.artist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.typ {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.date.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.popularity {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, v);
        }
        for value in &self.genre {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.cover {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.external_id {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.disc {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.review {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.copyright {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.restriction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.related {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sale_period {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.cover_group.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gid.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.artist {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.typ {
            os.write_enum(4, v.value())?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.date.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.popularity {
            os.write_sint32(7, v)?;
        }
        for v in &self.genre {
            os.write_string(8, &v)?;
        };
        for v in &self.cover {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.external_id {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.disc {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.review {
            os.write_string(12, &v)?;
        };
        for v in &self.copyright {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.restriction {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.related {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sale_period {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.cover_group.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Album {
        Album::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gid",
                    |m: &Album| { &m.gid },
                    |m: &mut Album| { &mut m.gid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Album| { &m.name },
                    |m: &mut Album| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Artist>>(
                    "artist",
                    |m: &Album| { &m.artist },
                    |m: &mut Album| { &mut m.artist },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Album_Type>>(
                    "typ",
                    |m: &Album| { &m.typ },
                    |m: &mut Album| { &mut m.typ },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &Album| { &m.label },
                    |m: &mut Album| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Date>>(
                    "date",
                    |m: &Album| { &m.date },
                    |m: &mut Album| { &mut m.date },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "popularity",
                    |m: &Album| { &m.popularity },
                    |m: &mut Album| { &mut m.popularity },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "genre",
                    |m: &Album| { &m.genre },
                    |m: &mut Album| { &mut m.genre },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                    "cover",
                    |m: &Album| { &m.cover },
                    |m: &mut Album| { &mut m.cover },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalId>>(
                    "external_id",
                    |m: &Album| { &m.external_id },
                    |m: &mut Album| { &mut m.external_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Disc>>(
                    "disc",
                    |m: &Album| { &m.disc },
                    |m: &mut Album| { &mut m.disc },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "review",
                    |m: &Album| { &m.review },
                    |m: &mut Album| { &mut m.review },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Copyright>>(
                    "copyright",
                    |m: &Album| { &m.copyright },
                    |m: &mut Album| { &mut m.copyright },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Restriction>>(
                    "restriction",
                    |m: &Album| { &m.restriction },
                    |m: &mut Album| { &mut m.restriction },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Album>>(
                    "related",
                    |m: &Album| { &m.related },
                    |m: &mut Album| { &mut m.related },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SalePeriod>>(
                    "sale_period",
                    |m: &Album| { &m.sale_period },
                    |m: &mut Album| { &mut m.sale_period },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageGroup>>(
                    "cover_group",
                    |m: &Album| { &m.cover_group },
                    |m: &mut Album| { &mut m.cover_group },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Album>(
                    "Album",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Album {
        static mut instance: ::protobuf::lazy::Lazy<Album> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Album,
        };
        unsafe {
            instance.get(Album::new)
        }
    }
}

impl ::protobuf::Clear for Album {
    fn clear(&mut self) {
        self.gid.clear();
        self.name.clear();
        self.artist.clear();
        self.typ = ::std::option::Option::None;
        self.label.clear();
        self.date.clear();
        self.popularity = ::std::option::Option::None;
        self.genre.clear();
        self.cover.clear();
        self.external_id.clear();
        self.disc.clear();
        self.review.clear();
        self.copyright.clear();
        self.restriction.clear();
        self.related.clear();
        self.sale_period.clear();
        self.cover_group.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Album {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Album {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Album_Type {
    ALBUM = 1,
    SINGLE = 2,
    COMPILATION = 3,
    EP = 4,
}

impl ::protobuf::ProtobufEnum for Album_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Album_Type> {
        match value {
            1 => ::std::option::Option::Some(Album_Type::ALBUM),
            2 => ::std::option::Option::Some(Album_Type::SINGLE),
            3 => ::std::option::Option::Some(Album_Type::COMPILATION),
            4 => ::std::option::Option::Some(Album_Type::EP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Album_Type] = &[
            Album_Type::ALBUM,
            Album_Type::SINGLE,
            Album_Type::COMPILATION,
            Album_Type::EP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Album_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Album_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Album_Type {
    fn default() -> Self {
        Album_Type::ALBUM
    }
}

impl ::protobuf::reflect::ProtobufValue for Album_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Track {
    // message fields
    gid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    name: ::protobuf::SingularField<::std::string::String>,
    album: ::protobuf::SingularPtrField<Album>,
    artist: ::protobuf::RepeatedField<Artist>,
    number: ::std::option::Option<i32>,
    disc_number: ::std::option::Option<i32>,
    duration: ::std::option::Option<i32>,
    popularity: ::std::option::Option<i32>,
    explicit: ::std::option::Option<bool>,
    external_id: ::protobuf::RepeatedField<ExternalId>,
    restriction: ::protobuf::RepeatedField<Restriction>,
    file: ::protobuf::RepeatedField<AudioFile>,
    alternative: ::protobuf::RepeatedField<Track>,
    sale_period: ::protobuf::RepeatedField<SalePeriod>,
    preview: ::protobuf::RepeatedField<AudioFile>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Track {
    fn default() -> &'a Track {
        <Track as ::protobuf::Message>::default_instance()
    }
}

impl Track {
    pub fn new() -> Track {
        ::std::default::Default::default()
    }

    // optional bytes gid = 1;


    pub fn get_gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_gid(&mut self) {
        self.gid.clear();
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid.set_default();
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .Album album = 3;


    pub fn get_album(&self) -> &Album {
        self.album.as_ref().unwrap_or_else(|| Album::default_instance())
    }
    pub fn clear_album(&mut self) {
        self.album.clear();
    }

    pub fn has_album(&self) -> bool {
        self.album.is_some()
    }

    // Param is passed by value, moved
    pub fn set_album(&mut self, v: Album) {
        self.album = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_album(&mut self) -> &mut Album {
        if self.album.is_none() {
            self.album.set_default();
        }
        self.album.as_mut().unwrap()
    }

    // Take field
    pub fn take_album(&mut self) -> Album {
        self.album.take().unwrap_or_else(|| Album::new())
    }

    // repeated .Artist artist = 4;


    pub fn get_artist(&self) -> &[Artist] {
        &self.artist
    }
    pub fn clear_artist(&mut self) {
        self.artist.clear();
    }

    // Param is passed by value, moved
    pub fn set_artist(&mut self, v: ::protobuf::RepeatedField<Artist>) {
        self.artist = v;
    }

    // Mutable pointer to the field.
    pub fn mut_artist(&mut self) -> &mut ::protobuf::RepeatedField<Artist> {
        &mut self.artist
    }

    // Take field
    pub fn take_artist(&mut self) -> ::protobuf::RepeatedField<Artist> {
        ::std::mem::replace(&mut self.artist, ::protobuf::RepeatedField::new())
    }

    // optional sint32 number = 5;


    pub fn get_number(&self) -> i32 {
        self.number.unwrap_or(0)
    }
    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    // optional sint32 disc_number = 6;


    pub fn get_disc_number(&self) -> i32 {
        self.disc_number.unwrap_or(0)
    }
    pub fn clear_disc_number(&mut self) {
        self.disc_number = ::std::option::Option::None;
    }

    pub fn has_disc_number(&self) -> bool {
        self.disc_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disc_number(&mut self, v: i32) {
        self.disc_number = ::std::option::Option::Some(v);
    }

    // optional sint32 duration = 7;


    pub fn get_duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional sint32 popularity = 8;


    pub fn get_popularity(&self) -> i32 {
        self.popularity.unwrap_or(0)
    }
    pub fn clear_popularity(&mut self) {
        self.popularity = ::std::option::Option::None;
    }

    pub fn has_popularity(&self) -> bool {
        self.popularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_popularity(&mut self, v: i32) {
        self.popularity = ::std::option::Option::Some(v);
    }

    // optional bool explicit = 9;


    pub fn get_explicit(&self) -> bool {
        self.explicit.unwrap_or(false)
    }
    pub fn clear_explicit(&mut self) {
        self.explicit = ::std::option::Option::None;
    }

    pub fn has_explicit(&self) -> bool {
        self.explicit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit(&mut self, v: bool) {
        self.explicit = ::std::option::Option::Some(v);
    }

    // repeated .ExternalId external_id = 10;


    pub fn get_external_id(&self) -> &[ExternalId] {
        &self.external_id
    }
    pub fn clear_external_id(&mut self) {
        self.external_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_external_id(&mut self, v: ::protobuf::RepeatedField<ExternalId>) {
        self.external_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_external_id(&mut self) -> &mut ::protobuf::RepeatedField<ExternalId> {
        &mut self.external_id
    }

    // Take field
    pub fn take_external_id(&mut self) -> ::protobuf::RepeatedField<ExternalId> {
        ::std::mem::replace(&mut self.external_id, ::protobuf::RepeatedField::new())
    }

    // repeated .Restriction restriction = 11;


    pub fn get_restriction(&self) -> &[Restriction] {
        &self.restriction
    }
    pub fn clear_restriction(&mut self) {
        self.restriction.clear();
    }

    // Param is passed by value, moved
    pub fn set_restriction(&mut self, v: ::protobuf::RepeatedField<Restriction>) {
        self.restriction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_restriction(&mut self) -> &mut ::protobuf::RepeatedField<Restriction> {
        &mut self.restriction
    }

    // Take field
    pub fn take_restriction(&mut self) -> ::protobuf::RepeatedField<Restriction> {
        ::std::mem::replace(&mut self.restriction, ::protobuf::RepeatedField::new())
    }

    // repeated .AudioFile file = 12;


    pub fn get_file(&self) -> &[AudioFile] {
        &self.file
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::protobuf::RepeatedField<AudioFile>) {
        self.file = v;
    }

    // Mutable pointer to the field.
    pub fn mut_file(&mut self) -> &mut ::protobuf::RepeatedField<AudioFile> {
        &mut self.file
    }

    // Take field
    pub fn take_file(&mut self) -> ::protobuf::RepeatedField<AudioFile> {
        ::std::mem::replace(&mut self.file, ::protobuf::RepeatedField::new())
    }

    // repeated .Track alternative = 13;


    pub fn get_alternative(&self) -> &[Track] {
        &self.alternative
    }
    pub fn clear_alternative(&mut self) {
        self.alternative.clear();
    }

    // Param is passed by value, moved
    pub fn set_alternative(&mut self, v: ::protobuf::RepeatedField<Track>) {
        self.alternative = v;
    }

    // Mutable pointer to the field.
    pub fn mut_alternative(&mut self) -> &mut ::protobuf::RepeatedField<Track> {
        &mut self.alternative
    }

    // Take field
    pub fn take_alternative(&mut self) -> ::protobuf::RepeatedField<Track> {
        ::std::mem::replace(&mut self.alternative, ::protobuf::RepeatedField::new())
    }

    // repeated .SalePeriod sale_period = 14;


    pub fn get_sale_period(&self) -> &[SalePeriod] {
        &self.sale_period
    }
    pub fn clear_sale_period(&mut self) {
        self.sale_period.clear();
    }

    // Param is passed by value, moved
    pub fn set_sale_period(&mut self, v: ::protobuf::RepeatedField<SalePeriod>) {
        self.sale_period = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sale_period(&mut self) -> &mut ::protobuf::RepeatedField<SalePeriod> {
        &mut self.sale_period
    }

    // Take field
    pub fn take_sale_period(&mut self) -> ::protobuf::RepeatedField<SalePeriod> {
        ::std::mem::replace(&mut self.sale_period, ::protobuf::RepeatedField::new())
    }

    // repeated .AudioFile preview = 15;


    pub fn get_preview(&self) -> &[AudioFile] {
        &self.preview
    }
    pub fn clear_preview(&mut self) {
        self.preview.clear();
    }

    // Param is passed by value, moved
    pub fn set_preview(&mut self, v: ::protobuf::RepeatedField<AudioFile>) {
        self.preview = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preview(&mut self) -> &mut ::protobuf::RepeatedField<AudioFile> {
        &mut self.preview
    }

    // Take field
    pub fn take_preview(&mut self) -> ::protobuf::RepeatedField<AudioFile> {
        ::std::mem::replace(&mut self.preview, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Track {
    fn is_initialized(&self) -> bool {
        for v in &self.album {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.artist {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.external_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restriction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.file {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.alternative {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sale_period {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preview {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.gid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.album)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.artist)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.number = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.disc_number = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.popularity = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.explicit = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.external_id)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.restriction)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.file)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.alternative)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sale_period)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preview)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.album.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.artist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.number {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, v);
        }
        if let Some(v) = self.disc_number {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, v);
        }
        if let Some(v) = self.popularity {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, v);
        }
        if let Some(v) = self.explicit {
            my_size += 2;
        }
        for value in &self.external_id {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.restriction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.file {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.alternative {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sale_period {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.preview {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gid.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.album.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.artist {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.number {
            os.write_sint32(5, v)?;
        }
        if let Some(v) = self.disc_number {
            os.write_sint32(6, v)?;
        }
        if let Some(v) = self.duration {
            os.write_sint32(7, v)?;
        }
        if let Some(v) = self.popularity {
            os.write_sint32(8, v)?;
        }
        if let Some(v) = self.explicit {
            os.write_bool(9, v)?;
        }
        for v in &self.external_id {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.restriction {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.file {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.alternative {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sale_period {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.preview {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Track {
        Track::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gid",
                    |m: &Track| { &m.gid },
                    |m: &mut Track| { &mut m.gid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Track| { &m.name },
                    |m: &mut Track| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Album>>(
                    "album",
                    |m: &Track| { &m.album },
                    |m: &mut Track| { &mut m.album },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Artist>>(
                    "artist",
                    |m: &Track| { &m.artist },
                    |m: &mut Track| { &mut m.artist },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "number",
                    |m: &Track| { &m.number },
                    |m: &mut Track| { &mut m.number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "disc_number",
                    |m: &Track| { &m.disc_number },
                    |m: &mut Track| { &mut m.disc_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "duration",
                    |m: &Track| { &m.duration },
                    |m: &mut Track| { &mut m.duration },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "popularity",
                    |m: &Track| { &m.popularity },
                    |m: &mut Track| { &mut m.popularity },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "explicit",
                    |m: &Track| { &m.explicit },
                    |m: &mut Track| { &mut m.explicit },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalId>>(
                    "external_id",
                    |m: &Track| { &m.external_id },
                    |m: &mut Track| { &mut m.external_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Restriction>>(
                    "restriction",
                    |m: &Track| { &m.restriction },
                    |m: &mut Track| { &mut m.restriction },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AudioFile>>(
                    "file",
                    |m: &Track| { &m.file },
                    |m: &mut Track| { &mut m.file },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Track>>(
                    "alternative",
                    |m: &Track| { &m.alternative },
                    |m: &mut Track| { &mut m.alternative },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SalePeriod>>(
                    "sale_period",
                    |m: &Track| { &m.sale_period },
                    |m: &mut Track| { &mut m.sale_period },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AudioFile>>(
                    "preview",
                    |m: &Track| { &m.preview },
                    |m: &mut Track| { &mut m.preview },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Track>(
                    "Track",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Track {
        static mut instance: ::protobuf::lazy::Lazy<Track> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Track,
        };
        unsafe {
            instance.get(Track::new)
        }
    }
}

impl ::protobuf::Clear for Track {
    fn clear(&mut self) {
        self.gid.clear();
        self.name.clear();
        self.album.clear();
        self.artist.clear();
        self.number = ::std::option::Option::None;
        self.disc_number = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.popularity = ::std::option::Option::None;
        self.explicit = ::std::option::Option::None;
        self.external_id.clear();
        self.restriction.clear();
        self.file.clear();
        self.alternative.clear();
        self.sale_period.clear();
        self.preview.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Track {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Track {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Image {
    // message fields
    file_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    size: ::std::option::Option<Image_Size>,
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Image {
    fn default() -> &'a Image {
        <Image as ::protobuf::Message>::default_instance()
    }
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    // optional bytes file_id = 1;


    pub fn get_file_id(&self) -> &[u8] {
        match self.file_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_file_id(&mut self) {
        self.file_id.clear();
    }

    pub fn has_file_id(&self) -> bool {
        self.file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.file_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.file_id.is_none() {
            self.file_id.set_default();
        }
        self.file_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_id(&mut self) -> ::std::vec::Vec<u8> {
        self.file_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .Image.Size size = 2;


    pub fn get_size(&self) -> Image_Size {
        self.size.unwrap_or(Image_Size::DEFAULT)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: Image_Size) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional sint32 width = 3;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional sint32 height = 4;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Image {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.file_id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.size, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.file_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.file_id.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.size {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.width {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_sint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image {
        Image::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "file_id",
                    |m: &Image| { &m.file_id },
                    |m: &mut Image| { &mut m.file_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Image_Size>>(
                    "size",
                    |m: &Image| { &m.size },
                    |m: &mut Image| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "width",
                    |m: &Image| { &m.width },
                    |m: &mut Image| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "height",
                    |m: &Image| { &m.height },
                    |m: &mut Image| { &mut m.height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Image>(
                    "Image",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Image {
        static mut instance: ::protobuf::lazy::Lazy<Image> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Image,
        };
        unsafe {
            instance.get(Image::new)
        }
    }
}

impl ::protobuf::Clear for Image {
    fn clear(&mut self) {
        self.file_id.clear();
        self.size = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Image_Size {
    DEFAULT = 0,
    SMALL = 1,
    LARGE = 2,
    XLARGE = 3,
}

impl ::protobuf::ProtobufEnum for Image_Size {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Image_Size> {
        match value {
            0 => ::std::option::Option::Some(Image_Size::DEFAULT),
            1 => ::std::option::Option::Some(Image_Size::SMALL),
            2 => ::std::option::Option::Some(Image_Size::LARGE),
            3 => ::std::option::Option::Some(Image_Size::XLARGE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Image_Size] = &[
            Image_Size::DEFAULT,
            Image_Size::SMALL,
            Image_Size::LARGE,
            Image_Size::XLARGE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Image_Size", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Image_Size {
}

impl ::std::default::Default for Image_Size {
    fn default() -> Self {
        Image_Size::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for Image_Size {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageGroup {
    // message fields
    image: ::protobuf::RepeatedField<Image>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageGroup {
    fn default() -> &'a ImageGroup {
        <ImageGroup as ::protobuf::Message>::default_instance()
    }
}

impl ImageGroup {
    pub fn new() -> ImageGroup {
        ::std::default::Default::default()
    }

    // repeated .Image image = 1;


    pub fn get_image(&self) -> &[Image] {
        &self.image
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::protobuf::RepeatedField<Image>) {
        self.image = v;
    }

    // Mutable pointer to the field.
    pub fn mut_image(&mut self) -> &mut ::protobuf::RepeatedField<Image> {
        &mut self.image
    }

    // Take field
    pub fn take_image(&mut self) -> ::protobuf::RepeatedField<Image> {
        ::std::mem::replace(&mut self.image, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ImageGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.image {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageGroup {
        ImageGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                    "image",
                    |m: &ImageGroup| { &m.image },
                    |m: &mut ImageGroup| { &mut m.image },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ImageGroup>(
                    "ImageGroup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ImageGroup {
        static mut instance: ::protobuf::lazy::Lazy<ImageGroup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ImageGroup,
        };
        unsafe {
            instance.get(ImageGroup::new)
        }
    }
}

impl ::protobuf::Clear for ImageGroup {
    fn clear(&mut self) {
        self.image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Biography {
    // message fields
    text: ::protobuf::SingularField<::std::string::String>,
    portrait: ::protobuf::RepeatedField<Image>,
    portrait_group: ::protobuf::RepeatedField<ImageGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Biography {
    fn default() -> &'a Biography {
        <Biography as ::protobuf::Message>::default_instance()
    }
}

impl Biography {
    pub fn new() -> Biography {
        ::std::default::Default::default()
    }

    // optional string text = 1;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .Image portrait = 2;


    pub fn get_portrait(&self) -> &[Image] {
        &self.portrait
    }
    pub fn clear_portrait(&mut self) {
        self.portrait.clear();
    }

    // Param is passed by value, moved
    pub fn set_portrait(&mut self, v: ::protobuf::RepeatedField<Image>) {
        self.portrait = v;
    }

    // Mutable pointer to the field.
    pub fn mut_portrait(&mut self) -> &mut ::protobuf::RepeatedField<Image> {
        &mut self.portrait
    }

    // Take field
    pub fn take_portrait(&mut self) -> ::protobuf::RepeatedField<Image> {
        ::std::mem::replace(&mut self.portrait, ::protobuf::RepeatedField::new())
    }

    // repeated .ImageGroup portrait_group = 3;


    pub fn get_portrait_group(&self) -> &[ImageGroup] {
        &self.portrait_group
    }
    pub fn clear_portrait_group(&mut self) {
        self.portrait_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_portrait_group(&mut self, v: ::protobuf::RepeatedField<ImageGroup>) {
        self.portrait_group = v;
    }

    // Mutable pointer to the field.
    pub fn mut_portrait_group(&mut self) -> &mut ::protobuf::RepeatedField<ImageGroup> {
        &mut self.portrait_group
    }

    // Take field
    pub fn take_portrait_group(&mut self) -> ::protobuf::RepeatedField<ImageGroup> {
        ::std::mem::replace(&mut self.portrait_group, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Biography {
    fn is_initialized(&self) -> bool {
        for v in &self.portrait {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.portrait_group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.portrait)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.portrait_group)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.portrait {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.portrait_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.portrait {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.portrait_group {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Biography {
        Biography::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &Biography| { &m.text },
                    |m: &mut Biography| { &mut m.text },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                    "portrait",
                    |m: &Biography| { &m.portrait },
                    |m: &mut Biography| { &mut m.portrait },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageGroup>>(
                    "portrait_group",
                    |m: &Biography| { &m.portrait_group },
                    |m: &mut Biography| { &mut m.portrait_group },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Biography>(
                    "Biography",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Biography {
        static mut instance: ::protobuf::lazy::Lazy<Biography> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Biography,
        };
        unsafe {
            instance.get(Biography::new)
        }
    }
}

impl ::protobuf::Clear for Biography {
    fn clear(&mut self) {
        self.text.clear();
        self.portrait.clear();
        self.portrait_group.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Biography {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Biography {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Disc {
    // message fields
    number: ::std::option::Option<i32>,
    name: ::protobuf::SingularField<::std::string::String>,
    track: ::protobuf::RepeatedField<Track>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Disc {
    fn default() -> &'a Disc {
        <Disc as ::protobuf::Message>::default_instance()
    }
}

impl Disc {
    pub fn new() -> Disc {
        ::std::default::Default::default()
    }

    // optional sint32 number = 1;


    pub fn get_number(&self) -> i32 {
        self.number.unwrap_or(0)
    }
    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .Track track = 3;


    pub fn get_track(&self) -> &[Track] {
        &self.track
    }
    pub fn clear_track(&mut self) {
        self.track.clear();
    }

    // Param is passed by value, moved
    pub fn set_track(&mut self, v: ::protobuf::RepeatedField<Track>) {
        self.track = v;
    }

    // Mutable pointer to the field.
    pub fn mut_track(&mut self) -> &mut ::protobuf::RepeatedField<Track> {
        &mut self.track
    }

    // Take field
    pub fn take_track(&mut self) -> ::protobuf::RepeatedField<Track> {
        ::std::mem::replace(&mut self.track, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Disc {
    fn is_initialized(&self) -> bool {
        for v in &self.track {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.track)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.number {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.track {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.number {
            os.write_sint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.track {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Disc {
        Disc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "number",
                    |m: &Disc| { &m.number },
                    |m: &mut Disc| { &mut m.number },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Disc| { &m.name },
                    |m: &mut Disc| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Track>>(
                    "track",
                    |m: &Disc| { &m.track },
                    |m: &mut Disc| { &mut m.track },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Disc>(
                    "Disc",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Disc {
        static mut instance: ::protobuf::lazy::Lazy<Disc> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Disc,
        };
        unsafe {
            instance.get(Disc::new)
        }
    }
}

impl ::protobuf::Clear for Disc {
    fn clear(&mut self) {
        self.number = ::std::option::Option::None;
        self.name.clear();
        self.track.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Disc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Disc {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Copyright {
    // message fields
    typ: ::std::option::Option<Copyright_Type>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Copyright {
    fn default() -> &'a Copyright {
        <Copyright as ::protobuf::Message>::default_instance()
    }
}

impl Copyright {
    pub fn new() -> Copyright {
        ::std::default::Default::default()
    }

    // optional .Copyright.Type typ = 1;


    pub fn get_typ(&self) -> Copyright_Type {
        self.typ.unwrap_or(Copyright_Type::P)
    }
    pub fn clear_typ(&mut self) {
        self.typ = ::std::option::Option::None;
    }

    pub fn has_typ(&self) -> bool {
        self.typ.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typ(&mut self, v: Copyright_Type) {
        self.typ = ::std::option::Option::Some(v);
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Copyright {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.typ, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.typ {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.typ {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Copyright {
        Copyright::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Copyright_Type>>(
                    "typ",
                    |m: &Copyright| { &m.typ },
                    |m: &mut Copyright| { &mut m.typ },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &Copyright| { &m.text },
                    |m: &mut Copyright| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Copyright>(
                    "Copyright",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Copyright {
        static mut instance: ::protobuf::lazy::Lazy<Copyright> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Copyright,
        };
        unsafe {
            instance.get(Copyright::new)
        }
    }
}

impl ::protobuf::Clear for Copyright {
    fn clear(&mut self) {
        self.typ = ::std::option::Option::None;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Copyright {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Copyright {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Copyright_Type {
    P = 0,
    C = 1,
}

impl ::protobuf::ProtobufEnum for Copyright_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Copyright_Type> {
        match value {
            0 => ::std::option::Option::Some(Copyright_Type::P),
            1 => ::std::option::Option::Some(Copyright_Type::C),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Copyright_Type] = &[
            Copyright_Type::P,
            Copyright_Type::C,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Copyright_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Copyright_Type {
}

impl ::std::default::Default for Copyright_Type {
    fn default() -> Self {
        Copyright_Type::P
    }
}

impl ::protobuf::reflect::ProtobufValue for Copyright_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Restriction {
    // message fields
    catalogue: ::std::vec::Vec<Restriction_Catalogue>,
    countries_allowed: ::protobuf::SingularField<::std::string::String>,
    countries_forbidden: ::protobuf::SingularField<::std::string::String>,
    typ: ::std::option::Option<Restriction_Type>,
    catalogue_str: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Restriction {
    fn default() -> &'a Restriction {
        <Restriction as ::protobuf::Message>::default_instance()
    }
}

impl Restriction {
    pub fn new() -> Restriction {
        ::std::default::Default::default()
    }

    // repeated .Restriction.Catalogue catalogue = 1;


    pub fn get_catalogue(&self) -> &[Restriction_Catalogue] {
        &self.catalogue
    }
    pub fn clear_catalogue(&mut self) {
        self.catalogue.clear();
    }

    // Param is passed by value, moved
    pub fn set_catalogue(&mut self, v: ::std::vec::Vec<Restriction_Catalogue>) {
        self.catalogue = v;
    }

    // Mutable pointer to the field.
    pub fn mut_catalogue(&mut self) -> &mut ::std::vec::Vec<Restriction_Catalogue> {
        &mut self.catalogue
    }

    // Take field
    pub fn take_catalogue(&mut self) -> ::std::vec::Vec<Restriction_Catalogue> {
        ::std::mem::replace(&mut self.catalogue, ::std::vec::Vec::new())
    }

    // optional string countries_allowed = 2;


    pub fn get_countries_allowed(&self) -> &str {
        match self.countries_allowed.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_countries_allowed(&mut self) {
        self.countries_allowed.clear();
    }

    pub fn has_countries_allowed(&self) -> bool {
        self.countries_allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_countries_allowed(&mut self, v: ::std::string::String) {
        self.countries_allowed = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_countries_allowed(&mut self) -> &mut ::std::string::String {
        if self.countries_allowed.is_none() {
            self.countries_allowed.set_default();
        }
        self.countries_allowed.as_mut().unwrap()
    }

    // Take field
    pub fn take_countries_allowed(&mut self) -> ::std::string::String {
        self.countries_allowed.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string countries_forbidden = 3;


    pub fn get_countries_forbidden(&self) -> &str {
        match self.countries_forbidden.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_countries_forbidden(&mut self) {
        self.countries_forbidden.clear();
    }

    pub fn has_countries_forbidden(&self) -> bool {
        self.countries_forbidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_countries_forbidden(&mut self, v: ::std::string::String) {
        self.countries_forbidden = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_countries_forbidden(&mut self) -> &mut ::std::string::String {
        if self.countries_forbidden.is_none() {
            self.countries_forbidden.set_default();
        }
        self.countries_forbidden.as_mut().unwrap()
    }

    // Take field
    pub fn take_countries_forbidden(&mut self) -> ::std::string::String {
        self.countries_forbidden.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .Restriction.Type typ = 4;


    pub fn get_typ(&self) -> Restriction_Type {
        self.typ.unwrap_or(Restriction_Type::STREAMING)
    }
    pub fn clear_typ(&mut self) {
        self.typ = ::std::option::Option::None;
    }

    pub fn has_typ(&self) -> bool {
        self.typ.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typ(&mut self, v: Restriction_Type) {
        self.typ = ::std::option::Option::Some(v);
    }

    // repeated string catalogue_str = 5;


    pub fn get_catalogue_str(&self) -> &[::std::string::String] {
        &self.catalogue_str
    }
    pub fn clear_catalogue_str(&mut self) {
        self.catalogue_str.clear();
    }

    // Param is passed by value, moved
    pub fn set_catalogue_str(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.catalogue_str = v;
    }

    // Mutable pointer to the field.
    pub fn mut_catalogue_str(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.catalogue_str
    }

    // Take field
    pub fn take_catalogue_str(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.catalogue_str, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Restriction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.catalogue, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.countries_allowed)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.countries_forbidden)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.typ, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.catalogue_str)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.catalogue {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        if let Some(ref v) = self.countries_allowed.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.countries_forbidden.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.typ {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        for value in &self.catalogue_str {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.catalogue {
            os.write_enum(1, v.value())?;
        };
        if let Some(ref v) = self.countries_allowed.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.countries_forbidden.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.typ {
            os.write_enum(4, v.value())?;
        }
        for v in &self.catalogue_str {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Restriction {
        Restriction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Restriction_Catalogue>>(
                    "catalogue",
                    |m: &Restriction| { &m.catalogue },
                    |m: &mut Restriction| { &mut m.catalogue },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "countries_allowed",
                    |m: &Restriction| { &m.countries_allowed },
                    |m: &mut Restriction| { &mut m.countries_allowed },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "countries_forbidden",
                    |m: &Restriction| { &m.countries_forbidden },
                    |m: &mut Restriction| { &mut m.countries_forbidden },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Restriction_Type>>(
                    "typ",
                    |m: &Restriction| { &m.typ },
                    |m: &mut Restriction| { &mut m.typ },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "catalogue_str",
                    |m: &Restriction| { &m.catalogue_str },
                    |m: &mut Restriction| { &mut m.catalogue_str },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Restriction>(
                    "Restriction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Restriction {
        static mut instance: ::protobuf::lazy::Lazy<Restriction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Restriction,
        };
        unsafe {
            instance.get(Restriction::new)
        }
    }
}

impl ::protobuf::Clear for Restriction {
    fn clear(&mut self) {
        self.catalogue.clear();
        self.countries_allowed.clear();
        self.countries_forbidden.clear();
        self.typ = ::std::option::Option::None;
        self.catalogue_str.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Restriction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Restriction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Restriction_Catalogue {
    AD = 0,
    SUBSCRIPTION = 1,
    CATALOGUE_ALL = 2,
    SHUFFLE = 3,
    COMMERCIAL = 4,
}

impl ::protobuf::ProtobufEnum for Restriction_Catalogue {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Restriction_Catalogue> {
        match value {
            0 => ::std::option::Option::Some(Restriction_Catalogue::AD),
            1 => ::std::option::Option::Some(Restriction_Catalogue::SUBSCRIPTION),
            2 => ::std::option::Option::Some(Restriction_Catalogue::CATALOGUE_ALL),
            3 => ::std::option::Option::Some(Restriction_Catalogue::SHUFFLE),
            4 => ::std::option::Option::Some(Restriction_Catalogue::COMMERCIAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Restriction_Catalogue] = &[
            Restriction_Catalogue::AD,
            Restriction_Catalogue::SUBSCRIPTION,
            Restriction_Catalogue::CATALOGUE_ALL,
            Restriction_Catalogue::SHUFFLE,
            Restriction_Catalogue::COMMERCIAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Restriction_Catalogue", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Restriction_Catalogue {
}

impl ::std::default::Default for Restriction_Catalogue {
    fn default() -> Self {
        Restriction_Catalogue::AD
    }
}

impl ::protobuf::reflect::ProtobufValue for Restriction_Catalogue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Restriction_Type {
    STREAMING = 0,
}

impl ::protobuf::ProtobufEnum for Restriction_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Restriction_Type> {
        match value {
            0 => ::std::option::Option::Some(Restriction_Type::STREAMING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Restriction_Type] = &[
            Restriction_Type::STREAMING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Restriction_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Restriction_Type {
}

impl ::std::default::Default for Restriction_Type {
    fn default() -> Self {
        Restriction_Type::STREAMING
    }
}

impl ::protobuf::reflect::ProtobufValue for Restriction_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Availability {
    // message fields
    catalogue_str: ::protobuf::RepeatedField<::std::string::String>,
    start: ::protobuf::SingularPtrField<Date>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Availability {
    fn default() -> &'a Availability {
        <Availability as ::protobuf::Message>::default_instance()
    }
}

impl Availability {
    pub fn new() -> Availability {
        ::std::default::Default::default()
    }

    // repeated string catalogue_str = 1;


    pub fn get_catalogue_str(&self) -> &[::std::string::String] {
        &self.catalogue_str
    }
    pub fn clear_catalogue_str(&mut self) {
        self.catalogue_str.clear();
    }

    // Param is passed by value, moved
    pub fn set_catalogue_str(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.catalogue_str = v;
    }

    // Mutable pointer to the field.
    pub fn mut_catalogue_str(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.catalogue_str
    }

    // Take field
    pub fn take_catalogue_str(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.catalogue_str, ::protobuf::RepeatedField::new())
    }

    // optional .Date start = 2;


    pub fn get_start(&self) -> &Date {
        self.start.as_ref().unwrap_or_else(|| Date::default_instance())
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: Date) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut Date {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> Date {
        self.start.take().unwrap_or_else(|| Date::new())
    }
}

impl ::protobuf::Message for Availability {
    fn is_initialized(&self) -> bool {
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.catalogue_str)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.catalogue_str {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.catalogue_str {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Availability {
        Availability::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "catalogue_str",
                    |m: &Availability| { &m.catalogue_str },
                    |m: &mut Availability| { &mut m.catalogue_str },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Date>>(
                    "start",
                    |m: &Availability| { &m.start },
                    |m: &mut Availability| { &mut m.start },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Availability>(
                    "Availability",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Availability {
        static mut instance: ::protobuf::lazy::Lazy<Availability> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Availability,
        };
        unsafe {
            instance.get(Availability::new)
        }
    }
}

impl ::protobuf::Clear for Availability {
    fn clear(&mut self) {
        self.catalogue_str.clear();
        self.start.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Availability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Availability {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SalePeriod {
    // message fields
    restriction: ::protobuf::RepeatedField<Restriction>,
    start: ::protobuf::SingularPtrField<Date>,
    end: ::protobuf::SingularPtrField<Date>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SalePeriod {
    fn default() -> &'a SalePeriod {
        <SalePeriod as ::protobuf::Message>::default_instance()
    }
}

impl SalePeriod {
    pub fn new() -> SalePeriod {
        ::std::default::Default::default()
    }

    // repeated .Restriction restriction = 1;


    pub fn get_restriction(&self) -> &[Restriction] {
        &self.restriction
    }
    pub fn clear_restriction(&mut self) {
        self.restriction.clear();
    }

    // Param is passed by value, moved
    pub fn set_restriction(&mut self, v: ::protobuf::RepeatedField<Restriction>) {
        self.restriction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_restriction(&mut self) -> &mut ::protobuf::RepeatedField<Restriction> {
        &mut self.restriction
    }

    // Take field
    pub fn take_restriction(&mut self) -> ::protobuf::RepeatedField<Restriction> {
        ::std::mem::replace(&mut self.restriction, ::protobuf::RepeatedField::new())
    }

    // optional .Date start = 2;


    pub fn get_start(&self) -> &Date {
        self.start.as_ref().unwrap_or_else(|| Date::default_instance())
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: Date) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut Date {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> Date {
        self.start.take().unwrap_or_else(|| Date::new())
    }

    // optional .Date end = 3;


    pub fn get_end(&self) -> &Date {
        self.end.as_ref().unwrap_or_else(|| Date::default_instance())
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: Date) {
        self.end = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut Date {
        if self.end.is_none() {
            self.end.set_default();
        }
        self.end.as_mut().unwrap()
    }

    // Take field
    pub fn take_end(&mut self) -> Date {
        self.end.take().unwrap_or_else(|| Date::new())
    }
}

impl ::protobuf::Message for SalePeriod {
    fn is_initialized(&self) -> bool {
        for v in &self.restriction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.restriction)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.restriction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.restriction {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SalePeriod {
        SalePeriod::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Restriction>>(
                    "restriction",
                    |m: &SalePeriod| { &m.restriction },
                    |m: &mut SalePeriod| { &mut m.restriction },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Date>>(
                    "start",
                    |m: &SalePeriod| { &m.start },
                    |m: &mut SalePeriod| { &mut m.start },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Date>>(
                    "end",
                    |m: &SalePeriod| { &m.end },
                    |m: &mut SalePeriod| { &mut m.end },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SalePeriod>(
                    "SalePeriod",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SalePeriod {
        static mut instance: ::protobuf::lazy::Lazy<SalePeriod> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SalePeriod,
        };
        unsafe {
            instance.get(SalePeriod::new)
        }
    }
}

impl ::protobuf::Clear for SalePeriod {
    fn clear(&mut self) {
        self.restriction.clear();
        self.start.clear();
        self.end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SalePeriod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SalePeriod {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExternalId {
    // message fields
    typ: ::protobuf::SingularField<::std::string::String>,
    id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternalId {
    fn default() -> &'a ExternalId {
        <ExternalId as ::protobuf::Message>::default_instance()
    }
}

impl ExternalId {
    pub fn new() -> ExternalId {
        ::std::default::Default::default()
    }

    // optional string typ = 1;


    pub fn get_typ(&self) -> &str {
        match self.typ.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_typ(&mut self) {
        self.typ.clear();
    }

    pub fn has_typ(&self) -> bool {
        self.typ.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typ(&mut self, v: ::std::string::String) {
        self.typ = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typ(&mut self) -> &mut ::std::string::String {
        if self.typ.is_none() {
            self.typ.set_default();
        }
        self.typ.as_mut().unwrap()
    }

    // Take field
    pub fn take_typ(&mut self) -> ::std::string::String {
        self.typ.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string id = 2;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ExternalId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.typ)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.typ.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.typ.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalId {
        ExternalId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "typ",
                    |m: &ExternalId| { &m.typ },
                    |m: &mut ExternalId| { &mut m.typ },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &ExternalId| { &m.id },
                    |m: &mut ExternalId| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExternalId>(
                    "ExternalId",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExternalId {
        static mut instance: ::protobuf::lazy::Lazy<ExternalId> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExternalId,
        };
        unsafe {
            instance.get(ExternalId::new)
        }
    }
}

impl ::protobuf::Clear for ExternalId {
    fn clear(&mut self) {
        self.typ.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalId {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AudioFile {
    // message fields
    file_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    format: ::std::option::Option<AudioFile_Format>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AudioFile {
    fn default() -> &'a AudioFile {
        <AudioFile as ::protobuf::Message>::default_instance()
    }
}

impl AudioFile {
    pub fn new() -> AudioFile {
        ::std::default::Default::default()
    }

    // optional bytes file_id = 1;


    pub fn get_file_id(&self) -> &[u8] {
        match self.file_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_file_id(&mut self) {
        self.file_id.clear();
    }

    pub fn has_file_id(&self) -> bool {
        self.file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.file_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.file_id.is_none() {
            self.file_id.set_default();
        }
        self.file_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_id(&mut self) -> ::std::vec::Vec<u8> {
        self.file_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .AudioFile.Format format = 2;


    pub fn get_format(&self) -> AudioFile_Format {
        self.format.unwrap_or(AudioFile_Format::OGG_VORBIS_96)
    }
    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: AudioFile_Format) {
        self.format = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AudioFile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.file_id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.format, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.file_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.file_id.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.format {
            os.write_enum(2, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AudioFile {
        AudioFile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "file_id",
                    |m: &AudioFile| { &m.file_id },
                    |m: &mut AudioFile| { &mut m.file_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AudioFile_Format>>(
                    "format",
                    |m: &AudioFile| { &m.format },
                    |m: &mut AudioFile| { &mut m.format },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AudioFile>(
                    "AudioFile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AudioFile {
        static mut instance: ::protobuf::lazy::Lazy<AudioFile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AudioFile,
        };
        unsafe {
            instance.get(AudioFile::new)
        }
    }
}

impl ::protobuf::Clear for AudioFile {
    fn clear(&mut self) {
        self.file_id.clear();
        self.format = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AudioFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioFile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AudioFile_Format {
    OGG_VORBIS_96 = 0,
    OGG_VORBIS_160 = 1,
    OGG_VORBIS_320 = 2,
    MP3_256 = 3,
    MP3_320 = 4,
    MP3_160 = 5,
    MP3_96 = 6,
    MP3_160_ENC = 7,
    MP4_128_DUAL = 8,
    OTHER3 = 9,
    AAC_160 = 10,
    AAC_320 = 11,
    MP4_128 = 12,
    OTHER5 = 13,
}

impl ::protobuf::ProtobufEnum for AudioFile_Format {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AudioFile_Format> {
        match value {
            0 => ::std::option::Option::Some(AudioFile_Format::OGG_VORBIS_96),
            1 => ::std::option::Option::Some(AudioFile_Format::OGG_VORBIS_160),
            2 => ::std::option::Option::Some(AudioFile_Format::OGG_VORBIS_320),
            3 => ::std::option::Option::Some(AudioFile_Format::MP3_256),
            4 => ::std::option::Option::Some(AudioFile_Format::MP3_320),
            5 => ::std::option::Option::Some(AudioFile_Format::MP3_160),
            6 => ::std::option::Option::Some(AudioFile_Format::MP3_96),
            7 => ::std::option::Option::Some(AudioFile_Format::MP3_160_ENC),
            8 => ::std::option::Option::Some(AudioFile_Format::MP4_128_DUAL),
            9 => ::std::option::Option::Some(AudioFile_Format::OTHER3),
            10 => ::std::option::Option::Some(AudioFile_Format::AAC_160),
            11 => ::std::option::Option::Some(AudioFile_Format::AAC_320),
            12 => ::std::option::Option::Some(AudioFile_Format::MP4_128),
            13 => ::std::option::Option::Some(AudioFile_Format::OTHER5),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AudioFile_Format] = &[
            AudioFile_Format::OGG_VORBIS_96,
            AudioFile_Format::OGG_VORBIS_160,
            AudioFile_Format::OGG_VORBIS_320,
            AudioFile_Format::MP3_256,
            AudioFile_Format::MP3_320,
            AudioFile_Format::MP3_160,
            AudioFile_Format::MP3_96,
            AudioFile_Format::MP3_160_ENC,
            AudioFile_Format::MP4_128_DUAL,
            AudioFile_Format::OTHER3,
            AudioFile_Format::AAC_160,
            AudioFile_Format::AAC_320,
            AudioFile_Format::MP4_128,
            AudioFile_Format::OTHER5,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AudioFile_Format", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AudioFile_Format {
}

impl ::std::default::Default for AudioFile_Format {
    fn default() -> Self {
        AudioFile_Format::OGG_VORBIS_96
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioFile_Format {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VideoFile {
    // message fields
    file_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoFile {
    fn default() -> &'a VideoFile {
        <VideoFile as ::protobuf::Message>::default_instance()
    }
}

impl VideoFile {
    pub fn new() -> VideoFile {
        ::std::default::Default::default()
    }

    // optional bytes file_id = 1;


    pub fn get_file_id(&self) -> &[u8] {
        match self.file_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_file_id(&mut self) {
        self.file_id.clear();
    }

    pub fn has_file_id(&self) -> bool {
        self.file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.file_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.file_id.is_none() {
            self.file_id.set_default();
        }
        self.file_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_id(&mut self) -> ::std::vec::Vec<u8> {
        self.file_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VideoFile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.file_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.file_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.file_id.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoFile {
        VideoFile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "file_id",
                    |m: &VideoFile| { &m.file_id },
                    |m: &mut VideoFile| { &mut m.file_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VideoFile>(
                    "VideoFile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VideoFile {
        static mut instance: ::protobuf::lazy::Lazy<VideoFile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VideoFile,
        };
        unsafe {
            instance.get(VideoFile::new)
        }
    }
}

impl ::protobuf::Clear for VideoFile {
    fn clear(&mut self) {
        self.file_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoFile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Show {
    // message fields
    gid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    name: ::protobuf::SingularField<::std::string::String>,
    description: ::protobuf::SingularField<::std::string::String>,
    deprecated_popularity: ::std::option::Option<i32>,
    publisher: ::protobuf::SingularField<::std::string::String>,
    language: ::protobuf::SingularField<::std::string::String>,
    explicit: ::std::option::Option<bool>,
    covers: ::protobuf::SingularPtrField<ImageGroup>,
    episode: ::protobuf::RepeatedField<Episode>,
    copyright: ::protobuf::RepeatedField<Copyright>,
    restriction: ::protobuf::RepeatedField<Restriction>,
    keyword: ::protobuf::RepeatedField<::std::string::String>,
    media_type: ::std::option::Option<Show_MediaType>,
    consumption_order: ::std::option::Option<Show_ConsumptionOrder>,
    interpret_restriction_using_geoip: ::std::option::Option<bool>,
    availability: ::protobuf::RepeatedField<Availability>,
    country_of_origin: ::protobuf::SingularField<::std::string::String>,
    categories: ::protobuf::RepeatedField<Category>,
    passthrough: ::std::option::Option<Show_PassthroughEnum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Show {
    fn default() -> &'a Show {
        <Show as ::protobuf::Message>::default_instance()
    }
}

impl Show {
    pub fn new() -> Show {
        ::std::default::Default::default()
    }

    // optional bytes gid = 1;


    pub fn get_gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_gid(&mut self) {
        self.gid.clear();
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid.set_default();
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 64;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint32 deprecated_popularity = 65;


    pub fn get_deprecated_popularity(&self) -> i32 {
        self.deprecated_popularity.unwrap_or(0)
    }
    pub fn clear_deprecated_popularity(&mut self) {
        self.deprecated_popularity = ::std::option::Option::None;
    }

    pub fn has_deprecated_popularity(&self) -> bool {
        self.deprecated_popularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_popularity(&mut self, v: i32) {
        self.deprecated_popularity = ::std::option::Option::Some(v);
    }

    // optional string publisher = 66;


    pub fn get_publisher(&self) -> &str {
        match self.publisher.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_publisher(&mut self) {
        self.publisher.clear();
    }

    pub fn has_publisher(&self) -> bool {
        self.publisher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publisher(&mut self, v: ::std::string::String) {
        self.publisher = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publisher(&mut self) -> &mut ::std::string::String {
        if self.publisher.is_none() {
            self.publisher.set_default();
        }
        self.publisher.as_mut().unwrap()
    }

    // Take field
    pub fn take_publisher(&mut self) -> ::std::string::String {
        self.publisher.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string language = 67;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool explicit = 68;


    pub fn get_explicit(&self) -> bool {
        self.explicit.unwrap_or(false)
    }
    pub fn clear_explicit(&mut self) {
        self.explicit = ::std::option::Option::None;
    }

    pub fn has_explicit(&self) -> bool {
        self.explicit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit(&mut self, v: bool) {
        self.explicit = ::std::option::Option::Some(v);
    }

    // optional .ImageGroup covers = 69;


    pub fn get_covers(&self) -> &ImageGroup {
        self.covers.as_ref().unwrap_or_else(|| ImageGroup::default_instance())
    }
    pub fn clear_covers(&mut self) {
        self.covers.clear();
    }

    pub fn has_covers(&self) -> bool {
        self.covers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_covers(&mut self, v: ImageGroup) {
        self.covers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_covers(&mut self) -> &mut ImageGroup {
        if self.covers.is_none() {
            self.covers.set_default();
        }
        self.covers.as_mut().unwrap()
    }

    // Take field
    pub fn take_covers(&mut self) -> ImageGroup {
        self.covers.take().unwrap_or_else(|| ImageGroup::new())
    }

    // repeated .Episode episode = 70;


    pub fn get_episode(&self) -> &[Episode] {
        &self.episode
    }
    pub fn clear_episode(&mut self) {
        self.episode.clear();
    }

    // Param is passed by value, moved
    pub fn set_episode(&mut self, v: ::protobuf::RepeatedField<Episode>) {
        self.episode = v;
    }

    // Mutable pointer to the field.
    pub fn mut_episode(&mut self) -> &mut ::protobuf::RepeatedField<Episode> {
        &mut self.episode
    }

    // Take field
    pub fn take_episode(&mut self) -> ::protobuf::RepeatedField<Episode> {
        ::std::mem::replace(&mut self.episode, ::protobuf::RepeatedField::new())
    }

    // repeated .Copyright copyright = 71;


    pub fn get_copyright(&self) -> &[Copyright] {
        &self.copyright
    }
    pub fn clear_copyright(&mut self) {
        self.copyright.clear();
    }

    // Param is passed by value, moved
    pub fn set_copyright(&mut self, v: ::protobuf::RepeatedField<Copyright>) {
        self.copyright = v;
    }

    // Mutable pointer to the field.
    pub fn mut_copyright(&mut self) -> &mut ::protobuf::RepeatedField<Copyright> {
        &mut self.copyright
    }

    // Take field
    pub fn take_copyright(&mut self) -> ::protobuf::RepeatedField<Copyright> {
        ::std::mem::replace(&mut self.copyright, ::protobuf::RepeatedField::new())
    }

    // repeated .Restriction restriction = 72;


    pub fn get_restriction(&self) -> &[Restriction] {
        &self.restriction
    }
    pub fn clear_restriction(&mut self) {
        self.restriction.clear();
    }

    // Param is passed by value, moved
    pub fn set_restriction(&mut self, v: ::protobuf::RepeatedField<Restriction>) {
        self.restriction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_restriction(&mut self) -> &mut ::protobuf::RepeatedField<Restriction> {
        &mut self.restriction
    }

    // Take field
    pub fn take_restriction(&mut self) -> ::protobuf::RepeatedField<Restriction> {
        ::std::mem::replace(&mut self.restriction, ::protobuf::RepeatedField::new())
    }

    // repeated string keyword = 73;


    pub fn get_keyword(&self) -> &[::std::string::String] {
        &self.keyword
    }
    pub fn clear_keyword(&mut self) {
        self.keyword.clear();
    }

    // Param is passed by value, moved
    pub fn set_keyword(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.keyword = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keyword(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.keyword
    }

    // Take field
    pub fn take_keyword(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.keyword, ::protobuf::RepeatedField::new())
    }

    // optional .Show.MediaType media_type = 74;


    pub fn get_media_type(&self) -> Show_MediaType {
        self.media_type.unwrap_or(Show_MediaType::MIXED)
    }
    pub fn clear_media_type(&mut self) {
        self.media_type = ::std::option::Option::None;
    }

    pub fn has_media_type(&self) -> bool {
        self.media_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media_type(&mut self, v: Show_MediaType) {
        self.media_type = ::std::option::Option::Some(v);
    }

    // optional .Show.ConsumptionOrder consumption_order = 75;


    pub fn get_consumption_order(&self) -> Show_ConsumptionOrder {
        self.consumption_order.unwrap_or(Show_ConsumptionOrder::SEQUENTIAL)
    }
    pub fn clear_consumption_order(&mut self) {
        self.consumption_order = ::std::option::Option::None;
    }

    pub fn has_consumption_order(&self) -> bool {
        self.consumption_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumption_order(&mut self, v: Show_ConsumptionOrder) {
        self.consumption_order = ::std::option::Option::Some(v);
    }

    // optional bool interpret_restriction_using_geoip = 76;


    pub fn get_interpret_restriction_using_geoip(&self) -> bool {
        self.interpret_restriction_using_geoip.unwrap_or(false)
    }
    pub fn clear_interpret_restriction_using_geoip(&mut self) {
        self.interpret_restriction_using_geoip = ::std::option::Option::None;
    }

    pub fn has_interpret_restriction_using_geoip(&self) -> bool {
        self.interpret_restriction_using_geoip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interpret_restriction_using_geoip(&mut self, v: bool) {
        self.interpret_restriction_using_geoip = ::std::option::Option::Some(v);
    }

    // repeated .Availability availability = 78;


    pub fn get_availability(&self) -> &[Availability] {
        &self.availability
    }
    pub fn clear_availability(&mut self) {
        self.availability.clear();
    }

    // Param is passed by value, moved
    pub fn set_availability(&mut self, v: ::protobuf::RepeatedField<Availability>) {
        self.availability = v;
    }

    // Mutable pointer to the field.
    pub fn mut_availability(&mut self) -> &mut ::protobuf::RepeatedField<Availability> {
        &mut self.availability
    }

    // Take field
    pub fn take_availability(&mut self) -> ::protobuf::RepeatedField<Availability> {
        ::std::mem::replace(&mut self.availability, ::protobuf::RepeatedField::new())
    }

    // optional string country_of_origin = 79;


    pub fn get_country_of_origin(&self) -> &str {
        match self.country_of_origin.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country_of_origin(&mut self) {
        self.country_of_origin.clear();
    }

    pub fn has_country_of_origin(&self) -> bool {
        self.country_of_origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_of_origin(&mut self, v: ::std::string::String) {
        self.country_of_origin = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_of_origin(&mut self) -> &mut ::std::string::String {
        if self.country_of_origin.is_none() {
            self.country_of_origin.set_default();
        }
        self.country_of_origin.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_of_origin(&mut self) -> ::std::string::String {
        self.country_of_origin.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .Category categories = 80;


    pub fn get_categories(&self) -> &[Category] {
        &self.categories
    }
    pub fn clear_categories(&mut self) {
        self.categories.clear();
    }

    // Param is passed by value, moved
    pub fn set_categories(&mut self, v: ::protobuf::RepeatedField<Category>) {
        self.categories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_categories(&mut self) -> &mut ::protobuf::RepeatedField<Category> {
        &mut self.categories
    }

    // Take field
    pub fn take_categories(&mut self) -> ::protobuf::RepeatedField<Category> {
        ::std::mem::replace(&mut self.categories, ::protobuf::RepeatedField::new())
    }

    // optional .Show.PassthroughEnum passthrough = 81;


    pub fn get_passthrough(&self) -> Show_PassthroughEnum {
        self.passthrough.unwrap_or(Show_PassthroughEnum::UNKNOWN)
    }
    pub fn clear_passthrough(&mut self) {
        self.passthrough = ::std::option::Option::None;
    }

    pub fn has_passthrough(&self) -> bool {
        self.passthrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passthrough(&mut self, v: Show_PassthroughEnum) {
        self.passthrough = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Show {
    fn is_initialized(&self) -> bool {
        for v in &self.covers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.episode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.copyright {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restriction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.availability {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.categories {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.gid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                64 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                65 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.deprecated_popularity = ::std::option::Option::Some(tmp);
                },
                66 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.publisher)?;
                },
                67 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                68 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.explicit = ::std::option::Option::Some(tmp);
                },
                69 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.covers)?;
                },
                70 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.episode)?;
                },
                71 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.copyright)?;
                },
                72 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.restriction)?;
                },
                73 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.keyword)?;
                },
                74 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.media_type, 74, &mut self.unknown_fields)?
                },
                75 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.consumption_order, 75, &mut self.unknown_fields)?
                },
                76 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.interpret_restriction_using_geoip = ::std::option::Option::Some(tmp);
                },
                78 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.availability)?;
                },
                79 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_of_origin)?;
                },
                80 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.categories)?;
                },
                81 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.passthrough, 81, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(64, &v);
        }
        if let Some(v) = self.deprecated_popularity {
            my_size += ::protobuf::rt::value_varint_zigzag_size(65, v);
        }
        if let Some(ref v) = self.publisher.as_ref() {
            my_size += ::protobuf::rt::string_size(66, &v);
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(67, &v);
        }
        if let Some(v) = self.explicit {
            my_size += 3;
        }
        if let Some(ref v) = self.covers.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.episode {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.copyright {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.restriction {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.keyword {
            my_size += ::protobuf::rt::string_size(73, &value);
        };
        if let Some(v) = self.media_type {
            my_size += ::protobuf::rt::enum_size(74, v);
        }
        if let Some(v) = self.consumption_order {
            my_size += ::protobuf::rt::enum_size(75, v);
        }
        if let Some(v) = self.interpret_restriction_using_geoip {
            my_size += 3;
        }
        for value in &self.availability {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.country_of_origin.as_ref() {
            my_size += ::protobuf::rt::string_size(79, &v);
        }
        for value in &self.categories {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.passthrough {
            my_size += ::protobuf::rt::enum_size(81, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gid.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(64, &v)?;
        }
        if let Some(v) = self.deprecated_popularity {
            os.write_sint32(65, v)?;
        }
        if let Some(ref v) = self.publisher.as_ref() {
            os.write_string(66, &v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(67, &v)?;
        }
        if let Some(v) = self.explicit {
            os.write_bool(68, v)?;
        }
        if let Some(ref v) = self.covers.as_ref() {
            os.write_tag(69, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.episode {
            os.write_tag(70, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.copyright {
            os.write_tag(71, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.restriction {
            os.write_tag(72, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.keyword {
            os.write_string(73, &v)?;
        };
        if let Some(v) = self.media_type {
            os.write_enum(74, v.value())?;
        }
        if let Some(v) = self.consumption_order {
            os.write_enum(75, v.value())?;
        }
        if let Some(v) = self.interpret_restriction_using_geoip {
            os.write_bool(76, v)?;
        }
        for v in &self.availability {
            os.write_tag(78, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.country_of_origin.as_ref() {
            os.write_string(79, &v)?;
        }
        for v in &self.categories {
            os.write_tag(80, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.passthrough {
            os.write_enum(81, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Show {
        Show::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gid",
                    |m: &Show| { &m.gid },
                    |m: &mut Show| { &mut m.gid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Show| { &m.name },
                    |m: &mut Show| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &Show| { &m.description },
                    |m: &mut Show| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "deprecated_popularity",
                    |m: &Show| { &m.deprecated_popularity },
                    |m: &mut Show| { &mut m.deprecated_popularity },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "publisher",
                    |m: &Show| { &m.publisher },
                    |m: &mut Show| { &mut m.publisher },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &Show| { &m.language },
                    |m: &mut Show| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "explicit",
                    |m: &Show| { &m.explicit },
                    |m: &mut Show| { &mut m.explicit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageGroup>>(
                    "covers",
                    |m: &Show| { &m.covers },
                    |m: &mut Show| { &mut m.covers },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Episode>>(
                    "episode",
                    |m: &Show| { &m.episode },
                    |m: &mut Show| { &mut m.episode },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Copyright>>(
                    "copyright",
                    |m: &Show| { &m.copyright },
                    |m: &mut Show| { &mut m.copyright },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Restriction>>(
                    "restriction",
                    |m: &Show| { &m.restriction },
                    |m: &mut Show| { &mut m.restriction },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "keyword",
                    |m: &Show| { &m.keyword },
                    |m: &mut Show| { &mut m.keyword },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Show_MediaType>>(
                    "media_type",
                    |m: &Show| { &m.media_type },
                    |m: &mut Show| { &mut m.media_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Show_ConsumptionOrder>>(
                    "consumption_order",
                    |m: &Show| { &m.consumption_order },
                    |m: &mut Show| { &mut m.consumption_order },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "interpret_restriction_using_geoip",
                    |m: &Show| { &m.interpret_restriction_using_geoip },
                    |m: &mut Show| { &mut m.interpret_restriction_using_geoip },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Availability>>(
                    "availability",
                    |m: &Show| { &m.availability },
                    |m: &mut Show| { &mut m.availability },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "country_of_origin",
                    |m: &Show| { &m.country_of_origin },
                    |m: &mut Show| { &mut m.country_of_origin },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Category>>(
                    "categories",
                    |m: &Show| { &m.categories },
                    |m: &mut Show| { &mut m.categories },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Show_PassthroughEnum>>(
                    "passthrough",
                    |m: &Show| { &m.passthrough },
                    |m: &mut Show| { &mut m.passthrough },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Show>(
                    "Show",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Show {
        static mut instance: ::protobuf::lazy::Lazy<Show> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Show,
        };
        unsafe {
            instance.get(Show::new)
        }
    }
}

impl ::protobuf::Clear for Show {
    fn clear(&mut self) {
        self.gid.clear();
        self.name.clear();
        self.description.clear();
        self.deprecated_popularity = ::std::option::Option::None;
        self.publisher.clear();
        self.language.clear();
        self.explicit = ::std::option::Option::None;
        self.covers.clear();
        self.episode.clear();
        self.copyright.clear();
        self.restriction.clear();
        self.keyword.clear();
        self.media_type = ::std::option::Option::None;
        self.consumption_order = ::std::option::Option::None;
        self.interpret_restriction_using_geoip = ::std::option::Option::None;
        self.availability.clear();
        self.country_of_origin.clear();
        self.categories.clear();
        self.passthrough = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Show {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Show {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Show_MediaType {
    MIXED = 0,
    AUDIO = 1,
    VIDEO = 2,
}

impl ::protobuf::ProtobufEnum for Show_MediaType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Show_MediaType> {
        match value {
            0 => ::std::option::Option::Some(Show_MediaType::MIXED),
            1 => ::std::option::Option::Some(Show_MediaType::AUDIO),
            2 => ::std::option::Option::Some(Show_MediaType::VIDEO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Show_MediaType] = &[
            Show_MediaType::MIXED,
            Show_MediaType::AUDIO,
            Show_MediaType::VIDEO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Show_MediaType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Show_MediaType {
}

impl ::std::default::Default for Show_MediaType {
    fn default() -> Self {
        Show_MediaType::MIXED
    }
}

impl ::protobuf::reflect::ProtobufValue for Show_MediaType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Show_ConsumptionOrder {
    SEQUENTIAL = 1,
    EPISODIC = 2,
    RECENT = 3,
}

impl ::protobuf::ProtobufEnum for Show_ConsumptionOrder {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Show_ConsumptionOrder> {
        match value {
            1 => ::std::option::Option::Some(Show_ConsumptionOrder::SEQUENTIAL),
            2 => ::std::option::Option::Some(Show_ConsumptionOrder::EPISODIC),
            3 => ::std::option::Option::Some(Show_ConsumptionOrder::RECENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Show_ConsumptionOrder] = &[
            Show_ConsumptionOrder::SEQUENTIAL,
            Show_ConsumptionOrder::EPISODIC,
            Show_ConsumptionOrder::RECENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Show_ConsumptionOrder", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Show_ConsumptionOrder {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Show_ConsumptionOrder {
    fn default() -> Self {
        Show_ConsumptionOrder::SEQUENTIAL
    }
}

impl ::protobuf::reflect::ProtobufValue for Show_ConsumptionOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Show_PassthroughEnum {
    UNKNOWN = 0,
    NONE = 1,
    ALLOWED = 2,
}

impl ::protobuf::ProtobufEnum for Show_PassthroughEnum {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Show_PassthroughEnum> {
        match value {
            0 => ::std::option::Option::Some(Show_PassthroughEnum::UNKNOWN),
            1 => ::std::option::Option::Some(Show_PassthroughEnum::NONE),
            2 => ::std::option::Option::Some(Show_PassthroughEnum::ALLOWED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Show_PassthroughEnum] = &[
            Show_PassthroughEnum::UNKNOWN,
            Show_PassthroughEnum::NONE,
            Show_PassthroughEnum::ALLOWED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Show_PassthroughEnum", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Show_PassthroughEnum {
}

impl ::std::default::Default for Show_PassthroughEnum {
    fn default() -> Self {
        Show_PassthroughEnum::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Show_PassthroughEnum {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Episode {
    // message fields
    gid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    name: ::protobuf::SingularField<::std::string::String>,
    duration: ::std::option::Option<i32>,
    popularity: ::std::option::Option<i32>,
    file: ::protobuf::RepeatedField<AudioFile>,
    description: ::protobuf::SingularField<::std::string::String>,
    number: ::std::option::Option<i32>,
    publish_time: ::protobuf::SingularPtrField<Date>,
    deprecated_popularity: ::std::option::Option<i32>,
    covers: ::protobuf::SingularPtrField<ImageGroup>,
    language: ::protobuf::SingularField<::std::string::String>,
    explicit: ::std::option::Option<bool>,
    show: ::protobuf::SingularPtrField<Show>,
    video: ::protobuf::RepeatedField<VideoFile>,
    video_preview: ::protobuf::RepeatedField<VideoFile>,
    audio_preview: ::protobuf::RepeatedField<AudioFile>,
    restriction: ::protobuf::RepeatedField<Restriction>,
    freeze_frame: ::protobuf::SingularPtrField<ImageGroup>,
    keyword: ::protobuf::RepeatedField<::std::string::String>,
    suppress_monetization: ::std::option::Option<bool>,
    interpret_restriction_using_geoip: ::std::option::Option<bool>,
    allow_background_playback: ::std::option::Option<bool>,
    availability: ::protobuf::RepeatedField<Availability>,
    external_url: ::protobuf::SingularField<::std::string::String>,
    original_audio: ::protobuf::SingularPtrField<OriginalAudio>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Episode {
    fn default() -> &'a Episode {
        <Episode as ::protobuf::Message>::default_instance()
    }
}

impl Episode {
    pub fn new() -> Episode {
        ::std::default::Default::default()
    }

    // optional bytes gid = 1;


    pub fn get_gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_gid(&mut self) {
        self.gid.clear();
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid.set_default();
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint32 duration = 7;


    pub fn get_duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional sint32 popularity = 8;


    pub fn get_popularity(&self) -> i32 {
        self.popularity.unwrap_or(0)
    }
    pub fn clear_popularity(&mut self) {
        self.popularity = ::std::option::Option::None;
    }

    pub fn has_popularity(&self) -> bool {
        self.popularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_popularity(&mut self, v: i32) {
        self.popularity = ::std::option::Option::Some(v);
    }

    // repeated .AudioFile file = 12;


    pub fn get_file(&self) -> &[AudioFile] {
        &self.file
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::protobuf::RepeatedField<AudioFile>) {
        self.file = v;
    }

    // Mutable pointer to the field.
    pub fn mut_file(&mut self) -> &mut ::protobuf::RepeatedField<AudioFile> {
        &mut self.file
    }

    // Take field
    pub fn take_file(&mut self) -> ::protobuf::RepeatedField<AudioFile> {
        ::std::mem::replace(&mut self.file, ::protobuf::RepeatedField::new())
    }

    // optional string description = 64;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint32 number = 65;


    pub fn get_number(&self) -> i32 {
        self.number.unwrap_or(0)
    }
    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    // optional .Date publish_time = 66;


    pub fn get_publish_time(&self) -> &Date {
        self.publish_time.as_ref().unwrap_or_else(|| Date::default_instance())
    }
    pub fn clear_publish_time(&mut self) {
        self.publish_time.clear();
    }

    pub fn has_publish_time(&self) -> bool {
        self.publish_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publish_time(&mut self, v: Date) {
        self.publish_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publish_time(&mut self) -> &mut Date {
        if self.publish_time.is_none() {
            self.publish_time.set_default();
        }
        self.publish_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_publish_time(&mut self) -> Date {
        self.publish_time.take().unwrap_or_else(|| Date::new())
    }

    // optional sint32 deprecated_popularity = 67;


    pub fn get_deprecated_popularity(&self) -> i32 {
        self.deprecated_popularity.unwrap_or(0)
    }
    pub fn clear_deprecated_popularity(&mut self) {
        self.deprecated_popularity = ::std::option::Option::None;
    }

    pub fn has_deprecated_popularity(&self) -> bool {
        self.deprecated_popularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_popularity(&mut self, v: i32) {
        self.deprecated_popularity = ::std::option::Option::Some(v);
    }

    // optional .ImageGroup covers = 68;


    pub fn get_covers(&self) -> &ImageGroup {
        self.covers.as_ref().unwrap_or_else(|| ImageGroup::default_instance())
    }
    pub fn clear_covers(&mut self) {
        self.covers.clear();
    }

    pub fn has_covers(&self) -> bool {
        self.covers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_covers(&mut self, v: ImageGroup) {
        self.covers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_covers(&mut self) -> &mut ImageGroup {
        if self.covers.is_none() {
            self.covers.set_default();
        }
        self.covers.as_mut().unwrap()
    }

    // Take field
    pub fn take_covers(&mut self) -> ImageGroup {
        self.covers.take().unwrap_or_else(|| ImageGroup::new())
    }

    // optional string language = 69;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool explicit = 70;


    pub fn get_explicit(&self) -> bool {
        self.explicit.unwrap_or(false)
    }
    pub fn clear_explicit(&mut self) {
        self.explicit = ::std::option::Option::None;
    }

    pub fn has_explicit(&self) -> bool {
        self.explicit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit(&mut self, v: bool) {
        self.explicit = ::std::option::Option::Some(v);
    }

    // optional .Show show = 71;


    pub fn get_show(&self) -> &Show {
        self.show.as_ref().unwrap_or_else(|| Show::default_instance())
    }
    pub fn clear_show(&mut self) {
        self.show.clear();
    }

    pub fn has_show(&self) -> bool {
        self.show.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: Show) {
        self.show = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_show(&mut self) -> &mut Show {
        if self.show.is_none() {
            self.show.set_default();
        }
        self.show.as_mut().unwrap()
    }

    // Take field
    pub fn take_show(&mut self) -> Show {
        self.show.take().unwrap_or_else(|| Show::new())
    }

    // repeated .VideoFile video = 72;


    pub fn get_video(&self) -> &[VideoFile] {
        &self.video
    }
    pub fn clear_video(&mut self) {
        self.video.clear();
    }

    // Param is passed by value, moved
    pub fn set_video(&mut self, v: ::protobuf::RepeatedField<VideoFile>) {
        self.video = v;
    }

    // Mutable pointer to the field.
    pub fn mut_video(&mut self) -> &mut ::protobuf::RepeatedField<VideoFile> {
        &mut self.video
    }

    // Take field
    pub fn take_video(&mut self) -> ::protobuf::RepeatedField<VideoFile> {
        ::std::mem::replace(&mut self.video, ::protobuf::RepeatedField::new())
    }

    // repeated .VideoFile video_preview = 73;


    pub fn get_video_preview(&self) -> &[VideoFile] {
        &self.video_preview
    }
    pub fn clear_video_preview(&mut self) {
        self.video_preview.clear();
    }

    // Param is passed by value, moved
    pub fn set_video_preview(&mut self, v: ::protobuf::RepeatedField<VideoFile>) {
        self.video_preview = v;
    }

    // Mutable pointer to the field.
    pub fn mut_video_preview(&mut self) -> &mut ::protobuf::RepeatedField<VideoFile> {
        &mut self.video_preview
    }

    // Take field
    pub fn take_video_preview(&mut self) -> ::protobuf::RepeatedField<VideoFile> {
        ::std::mem::replace(&mut self.video_preview, ::protobuf::RepeatedField::new())
    }

    // repeated .AudioFile audio_preview = 74;


    pub fn get_audio_preview(&self) -> &[AudioFile] {
        &self.audio_preview
    }
    pub fn clear_audio_preview(&mut self) {
        self.audio_preview.clear();
    }

    // Param is passed by value, moved
    pub fn set_audio_preview(&mut self, v: ::protobuf::RepeatedField<AudioFile>) {
        self.audio_preview = v;
    }

    // Mutable pointer to the field.
    pub fn mut_audio_preview(&mut self) -> &mut ::protobuf::RepeatedField<AudioFile> {
        &mut self.audio_preview
    }

    // Take field
    pub fn take_audio_preview(&mut self) -> ::protobuf::RepeatedField<AudioFile> {
        ::std::mem::replace(&mut self.audio_preview, ::protobuf::RepeatedField::new())
    }

    // repeated .Restriction restriction = 75;


    pub fn get_restriction(&self) -> &[Restriction] {
        &self.restriction
    }
    pub fn clear_restriction(&mut self) {
        self.restriction.clear();
    }

    // Param is passed by value, moved
    pub fn set_restriction(&mut self, v: ::protobuf::RepeatedField<Restriction>) {
        self.restriction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_restriction(&mut self) -> &mut ::protobuf::RepeatedField<Restriction> {
        &mut self.restriction
    }

    // Take field
    pub fn take_restriction(&mut self) -> ::protobuf::RepeatedField<Restriction> {
        ::std::mem::replace(&mut self.restriction, ::protobuf::RepeatedField::new())
    }

    // optional .ImageGroup freeze_frame = 76;


    pub fn get_freeze_frame(&self) -> &ImageGroup {
        self.freeze_frame.as_ref().unwrap_or_else(|| ImageGroup::default_instance())
    }
    pub fn clear_freeze_frame(&mut self) {
        self.freeze_frame.clear();
    }

    pub fn has_freeze_frame(&self) -> bool {
        self.freeze_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_freeze_frame(&mut self, v: ImageGroup) {
        self.freeze_frame = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_freeze_frame(&mut self) -> &mut ImageGroup {
        if self.freeze_frame.is_none() {
            self.freeze_frame.set_default();
        }
        self.freeze_frame.as_mut().unwrap()
    }

    // Take field
    pub fn take_freeze_frame(&mut self) -> ImageGroup {
        self.freeze_frame.take().unwrap_or_else(|| ImageGroup::new())
    }

    // repeated string keyword = 77;


    pub fn get_keyword(&self) -> &[::std::string::String] {
        &self.keyword
    }
    pub fn clear_keyword(&mut self) {
        self.keyword.clear();
    }

    // Param is passed by value, moved
    pub fn set_keyword(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.keyword = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keyword(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.keyword
    }

    // Take field
    pub fn take_keyword(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.keyword, ::protobuf::RepeatedField::new())
    }

    // optional bool suppress_monetization = 78;


    pub fn get_suppress_monetization(&self) -> bool {
        self.suppress_monetization.unwrap_or(false)
    }
    pub fn clear_suppress_monetization(&mut self) {
        self.suppress_monetization = ::std::option::Option::None;
    }

    pub fn has_suppress_monetization(&self) -> bool {
        self.suppress_monetization.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suppress_monetization(&mut self, v: bool) {
        self.suppress_monetization = ::std::option::Option::Some(v);
    }

    // optional bool interpret_restriction_using_geoip = 79;


    pub fn get_interpret_restriction_using_geoip(&self) -> bool {
        self.interpret_restriction_using_geoip.unwrap_or(false)
    }
    pub fn clear_interpret_restriction_using_geoip(&mut self) {
        self.interpret_restriction_using_geoip = ::std::option::Option::None;
    }

    pub fn has_interpret_restriction_using_geoip(&self) -> bool {
        self.interpret_restriction_using_geoip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interpret_restriction_using_geoip(&mut self, v: bool) {
        self.interpret_restriction_using_geoip = ::std::option::Option::Some(v);
    }

    // optional bool allow_background_playback = 81;


    pub fn get_allow_background_playback(&self) -> bool {
        self.allow_background_playback.unwrap_or(false)
    }
    pub fn clear_allow_background_playback(&mut self) {
        self.allow_background_playback = ::std::option::Option::None;
    }

    pub fn has_allow_background_playback(&self) -> bool {
        self.allow_background_playback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_background_playback(&mut self, v: bool) {
        self.allow_background_playback = ::std::option::Option::Some(v);
    }

    // repeated .Availability availability = 82;


    pub fn get_availability(&self) -> &[Availability] {
        &self.availability
    }
    pub fn clear_availability(&mut self) {
        self.availability.clear();
    }

    // Param is passed by value, moved
    pub fn set_availability(&mut self, v: ::protobuf::RepeatedField<Availability>) {
        self.availability = v;
    }

    // Mutable pointer to the field.
    pub fn mut_availability(&mut self) -> &mut ::protobuf::RepeatedField<Availability> {
        &mut self.availability
    }

    // Take field
    pub fn take_availability(&mut self) -> ::protobuf::RepeatedField<Availability> {
        ::std::mem::replace(&mut self.availability, ::protobuf::RepeatedField::new())
    }

    // optional string external_url = 83;


    pub fn get_external_url(&self) -> &str {
        match self.external_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_external_url(&mut self) {
        self.external_url.clear();
    }

    pub fn has_external_url(&self) -> bool {
        self.external_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_external_url(&mut self, v: ::std::string::String) {
        self.external_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_external_url(&mut self) -> &mut ::std::string::String {
        if self.external_url.is_none() {
            self.external_url.set_default();
        }
        self.external_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_external_url(&mut self) -> ::std::string::String {
        self.external_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .OriginalAudio original_audio = 84;


    pub fn get_original_audio(&self) -> &OriginalAudio {
        self.original_audio.as_ref().unwrap_or_else(|| OriginalAudio::default_instance())
    }
    pub fn clear_original_audio(&mut self) {
        self.original_audio.clear();
    }

    pub fn has_original_audio(&self) -> bool {
        self.original_audio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_audio(&mut self, v: OriginalAudio) {
        self.original_audio = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_audio(&mut self) -> &mut OriginalAudio {
        if self.original_audio.is_none() {
            self.original_audio.set_default();
        }
        self.original_audio.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_audio(&mut self) -> OriginalAudio {
        self.original_audio.take().unwrap_or_else(|| OriginalAudio::new())
    }
}

impl ::protobuf::Message for Episode {
    fn is_initialized(&self) -> bool {
        for v in &self.file {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.publish_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.covers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.show {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.video {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.video_preview {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.audio_preview {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restriction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.freeze_frame {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.availability {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.original_audio {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.gid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.popularity = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.file)?;
                },
                64 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                65 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.number = ::std::option::Option::Some(tmp);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.publish_time)?;
                },
                67 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.deprecated_popularity = ::std::option::Option::Some(tmp);
                },
                68 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.covers)?;
                },
                69 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                70 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.explicit = ::std::option::Option::Some(tmp);
                },
                71 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.show)?;
                },
                72 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.video)?;
                },
                73 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.video_preview)?;
                },
                74 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.audio_preview)?;
                },
                75 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.restriction)?;
                },
                76 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.freeze_frame)?;
                },
                77 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.keyword)?;
                },
                78 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.suppress_monetization = ::std::option::Option::Some(tmp);
                },
                79 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.interpret_restriction_using_geoip = ::std::option::Option::Some(tmp);
                },
                81 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_background_playback = ::std::option::Option::Some(tmp);
                },
                82 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.availability)?;
                },
                83 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.external_url)?;
                },
                84 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.original_audio)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, v);
        }
        if let Some(v) = self.popularity {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, v);
        }
        for value in &self.file {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(64, &v);
        }
        if let Some(v) = self.number {
            my_size += ::protobuf::rt::value_varint_zigzag_size(65, v);
        }
        if let Some(ref v) = self.publish_time.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.deprecated_popularity {
            my_size += ::protobuf::rt::value_varint_zigzag_size(67, v);
        }
        if let Some(ref v) = self.covers.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(69, &v);
        }
        if let Some(v) = self.explicit {
            my_size += 3;
        }
        if let Some(ref v) = self.show.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.video {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.video_preview {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.audio_preview {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.restriction {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.freeze_frame.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.keyword {
            my_size += ::protobuf::rt::string_size(77, &value);
        };
        if let Some(v) = self.suppress_monetization {
            my_size += 3;
        }
        if let Some(v) = self.interpret_restriction_using_geoip {
            my_size += 3;
        }
        if let Some(v) = self.allow_background_playback {
            my_size += 3;
        }
        for value in &self.availability {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.external_url.as_ref() {
            my_size += ::protobuf::rt::string_size(83, &v);
        }
        if let Some(ref v) = self.original_audio.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gid.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.duration {
            os.write_sint32(7, v)?;
        }
        if let Some(v) = self.popularity {
            os.write_sint32(8, v)?;
        }
        for v in &self.file {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(64, &v)?;
        }
        if let Some(v) = self.number {
            os.write_sint32(65, v)?;
        }
        if let Some(ref v) = self.publish_time.as_ref() {
            os.write_tag(66, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.deprecated_popularity {
            os.write_sint32(67, v)?;
        }
        if let Some(ref v) = self.covers.as_ref() {
            os.write_tag(68, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(69, &v)?;
        }
        if let Some(v) = self.explicit {
            os.write_bool(70, v)?;
        }
        if let Some(ref v) = self.show.as_ref() {
            os.write_tag(71, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.video {
            os.write_tag(72, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.video_preview {
            os.write_tag(73, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.audio_preview {
            os.write_tag(74, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.restriction {
            os.write_tag(75, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.freeze_frame.as_ref() {
            os.write_tag(76, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.keyword {
            os.write_string(77, &v)?;
        };
        if let Some(v) = self.suppress_monetization {
            os.write_bool(78, v)?;
        }
        if let Some(v) = self.interpret_restriction_using_geoip {
            os.write_bool(79, v)?;
        }
        if let Some(v) = self.allow_background_playback {
            os.write_bool(81, v)?;
        }
        for v in &self.availability {
            os.write_tag(82, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.external_url.as_ref() {
            os.write_string(83, &v)?;
        }
        if let Some(ref v) = self.original_audio.as_ref() {
            os.write_tag(84, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Episode {
        Episode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gid",
                    |m: &Episode| { &m.gid },
                    |m: &mut Episode| { &mut m.gid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Episode| { &m.name },
                    |m: &mut Episode| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "duration",
                    |m: &Episode| { &m.duration },
                    |m: &mut Episode| { &mut m.duration },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "popularity",
                    |m: &Episode| { &m.popularity },
                    |m: &mut Episode| { &mut m.popularity },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AudioFile>>(
                    "file",
                    |m: &Episode| { &m.file },
                    |m: &mut Episode| { &mut m.file },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &Episode| { &m.description },
                    |m: &mut Episode| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "number",
                    |m: &Episode| { &m.number },
                    |m: &mut Episode| { &mut m.number },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Date>>(
                    "publish_time",
                    |m: &Episode| { &m.publish_time },
                    |m: &mut Episode| { &mut m.publish_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "deprecated_popularity",
                    |m: &Episode| { &m.deprecated_popularity },
                    |m: &mut Episode| { &mut m.deprecated_popularity },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageGroup>>(
                    "covers",
                    |m: &Episode| { &m.covers },
                    |m: &mut Episode| { &mut m.covers },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &Episode| { &m.language },
                    |m: &mut Episode| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "explicit",
                    |m: &Episode| { &m.explicit },
                    |m: &mut Episode| { &mut m.explicit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Show>>(
                    "show",
                    |m: &Episode| { &m.show },
                    |m: &mut Episode| { &mut m.show },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoFile>>(
                    "video",
                    |m: &Episode| { &m.video },
                    |m: &mut Episode| { &mut m.video },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoFile>>(
                    "video_preview",
                    |m: &Episode| { &m.video_preview },
                    |m: &mut Episode| { &mut m.video_preview },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AudioFile>>(
                    "audio_preview",
                    |m: &Episode| { &m.audio_preview },
                    |m: &mut Episode| { &mut m.audio_preview },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Restriction>>(
                    "restriction",
                    |m: &Episode| { &m.restriction },
                    |m: &mut Episode| { &mut m.restriction },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageGroup>>(
                    "freeze_frame",
                    |m: &Episode| { &m.freeze_frame },
                    |m: &mut Episode| { &mut m.freeze_frame },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "keyword",
                    |m: &Episode| { &m.keyword },
                    |m: &mut Episode| { &mut m.keyword },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "suppress_monetization",
                    |m: &Episode| { &m.suppress_monetization },
                    |m: &mut Episode| { &mut m.suppress_monetization },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "interpret_restriction_using_geoip",
                    |m: &Episode| { &m.interpret_restriction_using_geoip },
                    |m: &mut Episode| { &mut m.interpret_restriction_using_geoip },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allow_background_playback",
                    |m: &Episode| { &m.allow_background_playback },
                    |m: &mut Episode| { &mut m.allow_background_playback },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Availability>>(
                    "availability",
                    |m: &Episode| { &m.availability },
                    |m: &mut Episode| { &mut m.availability },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "external_url",
                    |m: &Episode| { &m.external_url },
                    |m: &mut Episode| { &mut m.external_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OriginalAudio>>(
                    "original_audio",
                    |m: &Episode| { &m.original_audio },
                    |m: &mut Episode| { &mut m.original_audio },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Episode>(
                    "Episode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Episode {
        static mut instance: ::protobuf::lazy::Lazy<Episode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Episode,
        };
        unsafe {
            instance.get(Episode::new)
        }
    }
}

impl ::protobuf::Clear for Episode {
    fn clear(&mut self) {
        self.gid.clear();
        self.name.clear();
        self.duration = ::std::option::Option::None;
        self.popularity = ::std::option::Option::None;
        self.file.clear();
        self.description.clear();
        self.number = ::std::option::Option::None;
        self.publish_time.clear();
        self.deprecated_popularity = ::std::option::Option::None;
        self.covers.clear();
        self.language.clear();
        self.explicit = ::std::option::Option::None;
        self.show.clear();
        self.video.clear();
        self.video_preview.clear();
        self.audio_preview.clear();
        self.restriction.clear();
        self.freeze_frame.clear();
        self.keyword.clear();
        self.suppress_monetization = ::std::option::Option::None;
        self.interpret_restriction_using_geoip = ::std::option::Option::None;
        self.allow_background_playback = ::std::option::Option::None;
        self.availability.clear();
        self.external_url.clear();
        self.original_audio.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Episode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Episode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Category {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    subcategories: ::protobuf::RepeatedField<Category>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Category {
    fn default() -> &'a Category {
        <Category as ::protobuf::Message>::default_instance()
    }
}

impl Category {
    pub fn new() -> Category {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .Category subcategories = 2;


    pub fn get_subcategories(&self) -> &[Category] {
        &self.subcategories
    }
    pub fn clear_subcategories(&mut self) {
        self.subcategories.clear();
    }

    // Param is passed by value, moved
    pub fn set_subcategories(&mut self, v: ::protobuf::RepeatedField<Category>) {
        self.subcategories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subcategories(&mut self) -> &mut ::protobuf::RepeatedField<Category> {
        &mut self.subcategories
    }

    // Take field
    pub fn take_subcategories(&mut self) -> ::protobuf::RepeatedField<Category> {
        ::std::mem::replace(&mut self.subcategories, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Category {
    fn is_initialized(&self) -> bool {
        for v in &self.subcategories {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subcategories)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.subcategories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.subcategories {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Category {
        Category::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Category| { &m.name },
                    |m: &mut Category| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Category>>(
                    "subcategories",
                    |m: &Category| { &m.subcategories },
                    |m: &mut Category| { &mut m.subcategories },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Category>(
                    "Category",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Category {
        static mut instance: ::protobuf::lazy::Lazy<Category> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Category,
        };
        unsafe {
            instance.get(Category::new)
        }
    }
}

impl ::protobuf::Clear for Category {
    fn clear(&mut self) {
        self.name.clear();
        self.subcategories.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Category {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Category {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OriginalAudio {
    // message fields
    uuid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OriginalAudio {
    fn default() -> &'a OriginalAudio {
        <OriginalAudio as ::protobuf::Message>::default_instance()
    }
}

impl OriginalAudio {
    pub fn new() -> OriginalAudio {
        ::std::default::Default::default()
    }

    // optional bytes uuid = 1;


    pub fn get_uuid(&self) -> &[u8] {
        match self.uuid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::vec::Vec<u8>) {
        self.uuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.uuid.is_none() {
            self.uuid.set_default();
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::vec::Vec<u8> {
        self.uuid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OriginalAudio {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.uuid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.uuid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.uuid.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OriginalAudio {
        OriginalAudio::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "uuid",
                    |m: &OriginalAudio| { &m.uuid },
                    |m: &mut OriginalAudio| { &mut m.uuid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OriginalAudio>(
                    "OriginalAudio",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OriginalAudio {
        static mut instance: ::protobuf::lazy::Lazy<OriginalAudio> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OriginalAudio,
        };
        unsafe {
            instance.get(OriginalAudio::new)
        }
    }
}

impl ::protobuf::Clear for OriginalAudio {
    fn clear(&mut self) {
        self.uuid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OriginalAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OriginalAudio {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0emetadata.proto\x12\0\"9\n\tTopTracks\x12\x11\n\x07country\x18\x01\
    \x20\x01(\tB\0\x12\x17\n\x05track\x18\x02\x20\x03(\x0b2\x06.TrackB\0:\0\
    \"N\n\x0eActivityPeriod\x12\x14\n\nstart_year\x18\x01\x20\x01(\x11B\0\
    \x12\x12\n\x08end_year\x18\x02\x20\x01(\x11B\0\x12\x10\n\x06decade\x18\
    \x03\x20\x01(\x11B\0:\0\"\xa5\x04\n\x06Artist\x12\r\n\x03gid\x18\x01\x20\
    \x01(\x0cB\0\x12\x0e\n\x04name\x18\x02\x20\x01(\tB\0\x12\x14\n\npopulari\
    ty\x18\x03\x20\x01(\x11B\0\x12\x1f\n\ttop_track\x18\x04\x20\x03(\x0b2\n.\
    TopTracksB\0\x12\"\n\x0balbum_group\x18\x05\x20\x03(\x0b2\x0b.AlbumGroup\
    B\0\x12#\n\x0csingle_group\x18\x06\x20\x03(\x0b2\x0b.AlbumGroupB\0\x12(\
    \n\x11compilation_group\x18\x07\x20\x03(\x0b2\x0b.AlbumGroupB\0\x12'\n\
    \x10appears_on_group\x18\x08\x20\x03(\x0b2\x0b.AlbumGroupB\0\x12\x0f\n\
    \x05genre\x18\t\x20\x03(\tB\0\x12\"\n\x0bexternal_id\x18\n\x20\x03(\x0b2\
    \x0b.ExternalIdB\0\x12\x1a\n\x08portrait\x18\x0b\x20\x03(\x0b2\x06.Image\
    B\0\x12\x1f\n\tbiography\x18\x0c\x20\x03(\x0b2\n.BiographyB\0\x12*\n\x0f\
    activity_period\x18\r\x20\x03(\x0b2\x0f.ActivityPeriodB\0\x12#\n\x0brest\
    riction\x18\x0e\x20\x03(\x0b2\x0c.RestrictionB\0\x12\x1a\n\x07related\
    \x18\x0f\x20\x03(\x0b2\x07.ArtistB\0\x12!\n\x17is_portrait_album_cover\
    \x18\x10\x20\x01(\x08B\0\x12%\n\x0eportrait_group\x18\x11\x20\x01(\x0b2\
    \x0b.ImageGroupB\0:\0\"'\n\nAlbumGroup\x12\x17\n\x05album\x18\x01\x20\
    \x03(\x0b2\x06.AlbumB\0:\0\"Z\n\x04Date\x12\x0e\n\x04year\x18\x01\x20\
    \x01(\x11B\0\x12\x0f\n\x05month\x18\x02\x20\x01(\x11B\0\x12\r\n\x03day\
    \x18\x03\x20\x01(\x11B\0\x12\x0e\n\x04hour\x18\x04\x20\x01(\x11B\0\x12\
    \x10\n\x06minute\x18\x05\x20\x01(\x11B\0:\0\"\xf7\x03\n\x05Album\x12\r\n\
    \x03gid\x18\x01\x20\x01(\x0cB\0\x12\x0e\n\x04name\x18\x02\x20\x01(\tB\0\
    \x12\x19\n\x06artist\x18\x03\x20\x03(\x0b2\x07.ArtistB\0\x12\x1a\n\x03ty\
    p\x18\x04\x20\x01(\x0e2\x0b.Album.TypeB\0\x12\x0f\n\x05label\x18\x05\x20\
    \x01(\tB\0\x12\x15\n\x04date\x18\x06\x20\x01(\x0b2\x05.DateB\0\x12\x14\n\
    \npopularity\x18\x07\x20\x01(\x11B\0\x12\x0f\n\x05genre\x18\x08\x20\x03(\
    \tB\0\x12\x17\n\x05cover\x18\t\x20\x03(\x0b2\x06.ImageB\0\x12\"\n\x0bext\
    ernal_id\x18\n\x20\x03(\x0b2\x0b.ExternalIdB\0\x12\x15\n\x04disc\x18\x0b\
    \x20\x03(\x0b2\x05.DiscB\0\x12\x10\n\x06review\x18\x0c\x20\x03(\tB\0\x12\
    \x1f\n\tcopyright\x18\r\x20\x03(\x0b2\n.CopyrightB\0\x12#\n\x0brestricti\
    on\x18\x0e\x20\x03(\x0b2\x0c.RestrictionB\0\x12\x19\n\x07related\x18\x0f\
    \x20\x03(\x0b2\x06.AlbumB\0\x12\"\n\x0bsale_period\x18\x10\x20\x03(\x0b2\
    \x0b.SalePeriodB\0\x12\"\n\x0bcover_group\x18\x11\x20\x01(\x0b2\x0b.Imag\
    eGroupB\0\"8\n\x04Type\x12\t\n\x05ALBUM\x10\x01\x12\n\n\x06SINGLE\x10\
    \x02\x12\x0f\n\x0bCOMPILATION\x10\x03\x12\x06\n\x02EP\x10\x04\x1a\0:\0\"\
    \x8a\x03\n\x05Track\x12\r\n\x03gid\x18\x01\x20\x01(\x0cB\0\x12\x0e\n\x04\
    name\x18\x02\x20\x01(\tB\0\x12\x17\n\x05album\x18\x03\x20\x01(\x0b2\x06.\
    AlbumB\0\x12\x19\n\x06artist\x18\x04\x20\x03(\x0b2\x07.ArtistB\0\x12\x10\
    \n\x06number\x18\x05\x20\x01(\x11B\0\x12\x15\n\x0bdisc_number\x18\x06\
    \x20\x01(\x11B\0\x12\x12\n\x08duration\x18\x07\x20\x01(\x11B\0\x12\x14\n\
    \npopularity\x18\x08\x20\x01(\x11B\0\x12\x12\n\x08explicit\x18\t\x20\x01\
    (\x08B\0\x12\"\n\x0bexternal_id\x18\n\x20\x03(\x0b2\x0b.ExternalIdB\0\
    \x12#\n\x0brestriction\x18\x0b\x20\x03(\x0b2\x0c.RestrictionB\0\x12\x1a\
    \n\x04file\x18\x0c\x20\x03(\x0b2\n.AudioFileB\0\x12\x1d\n\x0balternative\
    \x18\r\x20\x03(\x0b2\x06.TrackB\0\x12\"\n\x0bsale_period\x18\x0e\x20\x03\
    (\x0b2\x0b.SalePeriodB\0\x12\x1d\n\x07preview\x18\x0f\x20\x03(\x0b2\n.Au\
    dioFileB\0:\0\"\x95\x01\n\x05Image\x12\x11\n\x07file_id\x18\x01\x20\x01(\
    \x0cB\0\x12\x1b\n\x04size\x18\x02\x20\x01(\x0e2\x0b.Image.SizeB\0\x12\
    \x0f\n\x05width\x18\x03\x20\x01(\x11B\0\x12\x10\n\x06height\x18\x04\x20\
    \x01(\x11B\0\"7\n\x04Size\x12\x0b\n\x07DEFAULT\x10\0\x12\t\n\x05SMALL\
    \x10\x01\x12\t\n\x05LARGE\x10\x02\x12\n\n\x06XLARGE\x10\x03\x1a\0:\0\"'\
    \n\nImageGroup\x12\x17\n\x05image\x18\x01\x20\x03(\x0b2\x06.ImageB\0:\0\
    \"`\n\tBiography\x12\x0e\n\x04text\x18\x01\x20\x01(\tB\0\x12\x1a\n\x08po\
    rtrait\x18\x02\x20\x03(\x0b2\x06.ImageB\0\x12%\n\x0eportrait_group\x18\
    \x03\x20\x03(\x0b2\x0b.ImageGroupB\0:\0\"C\n\x04Disc\x12\x10\n\x06number\
    \x18\x01\x20\x01(\x11B\0\x12\x0e\n\x04name\x18\x02\x20\x01(\tB\0\x12\x17\
    \n\x05track\x18\x03\x20\x03(\x0b2\x06.TrackB\0:\0\"U\n\tCopyright\x12\
    \x1e\n\x03typ\x18\x01\x20\x01(\x0e2\x0f.Copyright.TypeB\0\x12\x0e\n\x04t\
    ext\x18\x02\x20\x01(\tB\0\"\x16\n\x04Type\x12\x05\n\x01P\x10\0\x12\x05\n\
    \x01C\x10\x01\x1a\0:\0\"\xa5\x02\n\x0bRestriction\x12+\n\tcatalogue\x18\
    \x01\x20\x03(\x0e2\x16.Restriction.CatalogueB\0\x12\x1b\n\x11countries_a\
    llowed\x18\x02\x20\x01(\tB\0\x12\x1d\n\x13countries_forbidden\x18\x03\
    \x20\x01(\tB\0\x12\x20\n\x03typ\x18\x04\x20\x01(\x0e2\x11.Restriction.Ty\
    peB\0\x12\x17\n\rcatalogue_str\x18\x05\x20\x03(\tB\0\"W\n\tCatalogue\x12\
    \x06\n\x02AD\x10\0\x12\x10\n\x0cSUBSCRIPTION\x10\x01\x12\x11\n\rCATALOGU\
    E_ALL\x10\x02\x12\x0b\n\x07SHUFFLE\x10\x03\x12\x0e\n\nCOMMERCIAL\x10\x04\
    \x1a\0\"\x17\n\x04Type\x12\r\n\tSTREAMING\x10\0\x1a\0:\0\"A\n\x0cAvailab\
    ility\x12\x17\n\rcatalogue_str\x18\x01\x20\x03(\tB\0\x12\x16\n\x05start\
    \x18\x02\x20\x01(\x0b2\x05.DateB\0:\0\"a\n\nSalePeriod\x12#\n\x0brestric\
    tion\x18\x01\x20\x03(\x0b2\x0c.RestrictionB\0\x12\x16\n\x05start\x18\x02\
    \x20\x01(\x0b2\x05.DateB\0\x12\x14\n\x03end\x18\x03\x20\x01(\x0b2\x05.Da\
    teB\0:\0\"+\n\nExternalId\x12\r\n\x03typ\x18\x01\x20\x01(\tB\0\x12\x0c\n\
    \x02id\x18\x02\x20\x01(\tB\0:\0\"\xa2\x02\n\tAudioFile\x12\x11\n\x07file\
    _id\x18\x01\x20\x01(\x0cB\0\x12#\n\x06format\x18\x02\x20\x01(\x0e2\x11.A\
    udioFile.FormatB\0\"\xda\x01\n\x06Format\x12\x11\n\rOGG_VORBIS_96\x10\0\
    \x12\x12\n\x0eOGG_VORBIS_160\x10\x01\x12\x12\n\x0eOGG_VORBIS_320\x10\x02\
    \x12\x0b\n\x07MP3_256\x10\x03\x12\x0b\n\x07MP3_320\x10\x04\x12\x0b\n\x07\
    MP3_160\x10\x05\x12\n\n\x06MP3_96\x10\x06\x12\x0f\n\x0bMP3_160_ENC\x10\
    \x07\x12\x10\n\x0cMP4_128_DUAL\x10\x08\x12\n\n\x06OTHER3\x10\t\x12\x0b\n\
    \x07AAC_160\x10\n\x12\x0b\n\x07AAC_320\x10\x0b\x12\x0b\n\x07MP4_128\x10\
    \x0c\x12\n\n\x06OTHER5\x10\r\x1a\0:\0\"\x20\n\tVideoFile\x12\x11\n\x07fi\
    le_id\x18\x01\x20\x01(\x0cB\0:\0\"\xf6\x05\n\x04Show\x12\r\n\x03gid\x18\
    \x01\x20\x01(\x0cB\0\x12\x0e\n\x04name\x18\x02\x20\x01(\tB\0\x12\x15\n\
    \x0bdescription\x18@\x20\x01(\tB\0\x12\x1f\n\x15deprecated_popularity\
    \x18A\x20\x01(\x11B\0\x12\x13\n\tpublisher\x18B\x20\x01(\tB\0\x12\x12\n\
    \x08language\x18C\x20\x01(\tB\0\x12\x12\n\x08explicit\x18D\x20\x01(\x08B\
    \0\x12\x1d\n\x06covers\x18E\x20\x01(\x0b2\x0b.ImageGroupB\0\x12\x1b\n\
    \x07episode\x18F\x20\x03(\x0b2\x08.EpisodeB\0\x12\x1f\n\tcopyright\x18G\
    \x20\x03(\x0b2\n.CopyrightB\0\x12#\n\x0brestriction\x18H\x20\x03(\x0b2\
    \x0c.RestrictionB\0\x12\x11\n\x07keyword\x18I\x20\x03(\tB\0\x12%\n\nmedi\
    a_type\x18J\x20\x01(\x0e2\x0f.Show.MediaTypeB\0\x123\n\x11consumption_or\
    der\x18K\x20\x01(\x0e2\x16.Show.ConsumptionOrderB\0\x12+\n!interpret_res\
    triction_using_geoip\x18L\x20\x01(\x08B\0\x12%\n\x0cavailability\x18N\
    \x20\x03(\x0b2\r.AvailabilityB\0\x12\x1b\n\x11country_of_origin\x18O\x20\
    \x01(\tB\0\x12\x1f\n\ncategories\x18P\x20\x03(\x0b2\t.CategoryB\0\x12,\n\
    \x0bpassthrough\x18Q\x20\x01(\x0e2\x15.Show.PassthroughEnumB\0\".\n\tMed\
    iaType\x12\t\n\x05MIXED\x10\0\x12\t\n\x05AUDIO\x10\x01\x12\t\n\x05VIDEO\
    \x10\x02\x1a\0\">\n\x10ConsumptionOrder\x12\x0e\n\nSEQUENTIAL\x10\x01\
    \x12\x0c\n\x08EPISODIC\x10\x02\x12\n\n\x06RECENT\x10\x03\x1a\0\"7\n\x0fP\
    assthroughEnum\x12\x0b\n\x07UNKNOWN\x10\0\x12\x08\n\x04NONE\x10\x01\x12\
    \x0b\n\x07ALLOWED\x10\x02\x1a\0:\0\"\xd7\x05\n\x07Episode\x12\r\n\x03gid\
    \x18\x01\x20\x01(\x0cB\0\x12\x0e\n\x04name\x18\x02\x20\x01(\tB\0\x12\x12\
    \n\x08duration\x18\x07\x20\x01(\x11B\0\x12\x14\n\npopularity\x18\x08\x20\
    \x01(\x11B\0\x12\x1a\n\x04file\x18\x0c\x20\x03(\x0b2\n.AudioFileB\0\x12\
    \x15\n\x0bdescription\x18@\x20\x01(\tB\0\x12\x10\n\x06number\x18A\x20\
    \x01(\x11B\0\x12\x1d\n\x0cpublish_time\x18B\x20\x01(\x0b2\x05.DateB\0\
    \x12\x1f\n\x15deprecated_popularity\x18C\x20\x01(\x11B\0\x12\x1d\n\x06co\
    vers\x18D\x20\x01(\x0b2\x0b.ImageGroupB\0\x12\x12\n\x08language\x18E\x20\
    \x01(\tB\0\x12\x12\n\x08explicit\x18F\x20\x01(\x08B\0\x12\x15\n\x04show\
    \x18G\x20\x01(\x0b2\x05.ShowB\0\x12\x1b\n\x05video\x18H\x20\x03(\x0b2\n.\
    VideoFileB\0\x12#\n\rvideo_preview\x18I\x20\x03(\x0b2\n.VideoFileB\0\x12\
    #\n\raudio_preview\x18J\x20\x03(\x0b2\n.AudioFileB\0\x12#\n\x0brestricti\
    on\x18K\x20\x03(\x0b2\x0c.RestrictionB\0\x12#\n\x0cfreeze_frame\x18L\x20\
    \x01(\x0b2\x0b.ImageGroupB\0\x12\x11\n\x07keyword\x18M\x20\x03(\tB\0\x12\
    \x1f\n\x15suppress_monetization\x18N\x20\x01(\x08B\0\x12+\n!interpret_re\
    striction_using_geoip\x18O\x20\x01(\x08B\0\x12#\n\x19allow_background_pl\
    ayback\x18Q\x20\x01(\x08B\0\x12%\n\x0cavailability\x18R\x20\x03(\x0b2\r.\
    AvailabilityB\0\x12\x16\n\x0cexternal_url\x18S\x20\x01(\tB\0\x12(\n\x0eo\
    riginal_audio\x18T\x20\x01(\x0b2\x0e.OriginalAudioB\0:\0\"@\n\x08Categor\
    y\x12\x0e\n\x04name\x18\x01\x20\x01(\tB\0\x12\"\n\rsubcategories\x18\x02\
    \x20\x03(\x0b2\t.CategoryB\0:\0\"!\n\rOriginalAudio\x12\x0e\n\x04uuid\
    \x18\x01\x20\x01(\x0cB\0:\0B\0b\x06proto2\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
